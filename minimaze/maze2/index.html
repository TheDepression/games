<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Adventure: Post-Apocalyptic World</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        #gameContainer {
            width: 350px;
            height: 550px;
            background: #2a2a2a;
            border: 3px solid #555;
            border-radius: 15px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        
        #gameArea {
    width: 350px;
    height: 357.5px;
    position: relative;
    overflow: hidden;
    background: linear-gradient(45deg, #d2d4cb 0%, #bfbfb2 50%, #c1c7b3 100%);
    touch-action: none;
}
        
        #gameWorld {
            position: absolute;
            width: 2400px;
            height: 2400px;
            transform-origin: 0 0;
        }
        
        .apocalypse-overlay {
    position: absolute; /* Changed from fixed */
    top: 0;
    left: 0;
    width: 2400px; /* Match game world size */
    height: 2400px;
    background-image: 
        radial-gradient(ellipse 75px 30px at 15% 25%, rgba(100,100,100,0.3) 30%, transparent 70%),
        radial-gradient(ellipse 50px 20px at 65% 60%, rgba(80,80,80,0.25) 25%, transparent 65%),
        radial-gradient(ellipse 100px 40px at 35% 80%, rgba(60,60,60,0.2) 35%, transparent 75%),
        radial-gradient(ellipse 60px 25px at 85% 15%, rgba(90,90,90,0.28) 28%, transparent 68%),
        radial-gradient(ellipse 80px 35px at 25% 45%, rgba(70,70,70,0.22) 32%, transparent 72%);
    background-size: 400px 400px, 350px 350px, 500px 500px, 300px 300px, 450px 450px;
    background-position: 0 0, 200px 150px, 100px 300px, 350px 80px, 450px 400px;
    pointer-events: none;
    z-index: 151; /* Above zones but below UI */
    opacity: 0.55;
    filter: blur(1px);
    animation: fogDrift 50s ease-in-out infinite alternate;
}

@keyframes fogDrift {
    0% { 
        background-position: 0 0, 150px 100px, 75px 200px, 225px 50px, 300px 250px;
        opacity: 0.5;
    }
    50% {
        background-position: 100px 50px, 250px 150px, 175px 250px, 325px 100px, 400px 300px;
        opacity: 0.6;
    }
    100% { 
        background-position: 200px 100px, 350px 200px, 275px 300px, 425px 150px, 500px 350px;
        opacity: 0.5;
    }
}



        .apocalypse-overlay-fast {
    position: absolute;
    top: 0;
    left: 0;
    width: 2400px;
    height: 2400px;
    background-image: 
        radial-gradient(ellipse 150px 60px at 10% 15%, rgba(90,90,90,0.2) 25%, transparent 65%),
        radial-gradient(ellipse 120px 45px at 30% 35%, rgba(70,70,70,0.18) 20%, transparent 60%),
        radial-gradient(ellipse 180px 75px at 55% 55%, rgba(80,80,80,0.15) 30%, transparent 70%),
        radial-gradient(ellipse 140px 50px at 75% 25%, rgba(85,85,85,0.22) 25%, transparent 65%),
        radial-gradient(ellipse 160px 65px at 20% 75%, rgba(75,75,75,0.16) 28%, transparent 68%),
        radial-gradient(ellipse 110px 40px at 45% 10%, rgba(95,95,95,0.19) 22%, transparent 62%),
        radial-gradient(ellipse 170px 70px at 85% 65%, rgba(65,65,65,0.17) 26%, transparent 66%),
        radial-gradient(ellipse 130px 55px at 15% 45%, rgba(88,88,88,0.21) 24%, transparent 64%);
    background-size: 600px 600px, 500px 500px, 700px 700px, 550px 550px, 650px 650px, 480px 480px, 680px 680px, 520px 520px;
    background-position: 0 0, 300px 200px, 150px 400px, 450px 100px, 600px 500px, 250px 350px, 500px 250px, 100px 150px;
    pointer-events: none;
    z-index: 152; /* Above the original fog layer */
    opacity: 0.35;
    filter: blur(1.5px);
    animation: fastFogDrift 25s ease-in-out infinite alternate;
}

@keyframes fastFogDrift {
    0% { 
        background-position: 0 0, 200px 150px, 100px 300px, 350px 50px, 450px 400px, 150px 250px, 400px 200px, 50px 100px;
        opacity: 0.3;
    }
    50% {
        background-position: 300px 100px, 500px 250px, 400px 500px, 650px 200px, 750px 600px, 450px 450px, 700px 400px, 350px 300px;
        opacity: 0.4;
    }
    100% { 
        background-position: 600px 200px, 800px 350px, 700px 700px, 950px 350px, 1050px 800px, 750px 650px, 1000px 600px, 650px 500px;
        opacity: 0.3;
    }
}
        
        /* Copy all the zone styles from original but darker */
        .water-zone {
    position: absolute;
    background-image: 
        radial-gradient(circle at 25% 25%, rgba(200,200,255,0.3) 2px, transparent 2px),
        radial-gradient(circle at 75% 75%, rgba(150,150,200,0.2) 1px, transparent 1px),
        linear-gradient(135deg, #3a5a7a 0%, #2a4a6a 50%, #1a3a5a 100%);
    background-size: 20px 20px, 15px 15px, 100% 100%;
    background-position: 0 0, 10px 10px, 0 0;
    opacity: 0.8;
    animation: waterFlow 4s linear infinite;
}
        
        .forest-zone {
    position: absolute;
    background-image:
        repeating-conic-gradient(from 0deg at 50% 50%, 
            #2a4a2a 0deg 30deg, 
            #3a5a3a 30deg 60deg, 
            #4a6a4a 60deg 90deg, 
            #3a5a3a 90deg 120deg),
        radial-gradient(circle at 30% 40%, rgba(150,200,150,0.1) 1px, transparent 1px);
    background-size: 40px 40px, 25px 25px;
    background-position: 0 0, 20px 20px;
    opacity: 0.8;
}

        .forest-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-image:
        radial-gradient(circle at 20% 30%, #2e7d32 8px, transparent 8px),
        radial-gradient(circle at 60% 20%, #388e3c 6px, transparent 6px),
        radial-gradient(circle at 80% 60%, #4caf50 10px, transparent 10px),
        radial-gradient(circle at 30% 80%, #2e7d32 7px, transparent 7px),
        radial-gradient(circle at 70% 75%, #1b5e20 5px, transparent 5px),
        linear-gradient(135deg, rgba(46, 125, 50, 0.4) 0%, rgba(27, 94, 32, 0.6) 100%);
    background-size: 40px 40px, 60px 60px, 35px 35px, 50px 50px, 45px 45px, 100% 100%;
    background-position: 0 0, 20px 30px, 40px 10px, 10px 40px, 30px 20px, 0 0;
    pointer-events: none;
    z-index: 150;
    opacity: 0;
    transition: opacity 0.5s ease;
}

.forest-overlay.active {
    opacity: 0.8;
}

.forest-vision-mask {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: radial-gradient(circle 111px, transparent 111px, black 111px);
    pointer-events: none;
    z-index: 200;
    opacity: 0;
    transition: opacity 0.5s ease;
}

.forest-vision-mask.active {
    opacity: 1;
}

#confirmDialog {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 300;
}
        
        .desert-zone {
    position: absolute;
    background-image:
        linear-gradient(45deg, rgba(200,150,100,0.1) 25%, transparent 25%),
        linear-gradient(-45deg, rgba(200,150,100,0.1) 25%, transparent 25%),
        linear-gradient(45deg, transparent 75%, rgba(200,150,100,0.1) 75%),
        linear-gradient(-45deg, transparent 75%, rgba(200,150,100,0.1) 75%),
        linear-gradient(135deg, #ccaa02 0%, #cca107 50%, #cc9a00 100%);
    background-size: 30px 30px, 30px 30px, 30px 30px, 30px 30px, 100% 100%;
    background-position: 0 0, 0 15px, 15px -15px, -15px 0px, 0 0;
    opacity: 0.7;
}

        .castle-zone {
            position: absolute;
            background-image: url('https://raw.githubusercontent.com/TheDepression/Photos/main/castle.png');
            background-size: cover;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0.9;
            filter: grayscale(20%) brightness(0.6);
        }
        
        .grass-zone {
    position: absolute;
    background-image:
        repeating-linear-gradient(
            90deg,
            #3a6a3a 0px,
            #4a7a4a 2px,
            #3a6a3a 4px,
            #2a5a2a 6px
        ),
        repeating-linear-gradient(
            0deg,
            transparent 0px,
            rgba(200,255,200,0.1) 1px,
            transparent 2px
        );
    background-size: 8px 8px, 4px 4px;
    opacity: 0.8;
}
        
        .village-zone {
    position: absolute;
    background-image:
        repeating-linear-gradient(
            45deg,
            rgba(120, 200, 120, 0.3) 0px,
            rgba(140, 220, 140, 0.3) 4px,
            rgba(120, 200, 120, 0.3) 8px,
            rgba(130, 210, 130, 0.3) 12px
        );
    background-size: 16px 16px;
    background-color: rgba(120, 200, 120, 0.2);
    opacity: 0.6;
}
        
        .lava-zone {
            position: absolute;
            background-image:
                radial-gradient(circle at 25% 25%, #aa3a12 30%, transparent 30%),
                radial-gradient(circle at 75% 75%, #8a2a15 20%, transparent 20%),
                linear-gradient(45deg, #aa2a00 25%, transparent 25%),
                linear-gradient(-45deg, #7a1a0c 25%, transparent 25%);
            background-size: 40px 40px, 30px 30px, 20px 20px, 20px 20px;
            background-color: #aa3a12;
            opacity: 0.9;
            animation: lavaFlow 3s ease-in-out infinite;
        }
        
        @keyframes poisonWater {
            0% { background-position: 0 0, 10px 10px, 0 0; }
            100% { background-position: 20px 0, 30px 10px, 0 0; }
        }
        
        @keyframes lavaFlow {
            0%, 100% { filter: brightness(0.8) hue-rotate(0deg); }
            50% { filter: brightness(1) hue-rotate(10deg); }
        }
        
        .breakable-wall {
            position: absolute;
            background: #4a3a2a;
            border: 2px dashed #3a2a1a;
            opacity: 0.9;
        }
        
        .tiled-wall {
            position: absolute;
            background-image: url('https://raw.githubusercontent.com/TheDepression/Photos/main/tilerock.png');
            background-repeat: repeat;
            background-size: 20px 20px;
            border: 1px solid rgba(0,0,0,0.4);
            opacity: 0.9;
            filter: brightness(0.4) desaturate(0.5);
        }

        .fake-tiled-wall {
    position: absolute;
    background-image: url('https://raw.githubusercontent.com/TheDepression/Photos/main/tilerock.png');
    background-repeat: repeat;
    background-size: 20px 20px;
    border: 1px solid rgba(0,0,0,0.4);
    opacity: 0.9;
    filter: brightness(0.4) desaturate(0.5);
    z-index: 25; /* Same as regular walls but no collision */
    pointer-events: none; /* Make sure it doesn't interfere */
}
        
        .pathway {
            position: absolute;
            background: linear-gradient(135deg, #d1d1ba 0%, #91916d 50%, #9c9c73 100%);
            border: 1px solid rgba(100,100,80,0.2);
            opacity: 0.6;
            z-index: 25;
        }
        
        #player {
            position: absolute;
            width: 32px;
            height: 32px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 100;
            transition: none;
        }
        
        .invulnerable {
            animation: blink 0.2s infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }
        
        /* Attack animations from pyramid boss */
        @keyframes slashEffect {
            0% { 
                transform: scale(0.5) rotate(0deg);
                opacity: 1;
            }
            50% {
                transform: scale(1.2) rotate(0deg);
                opacity: 0.8;
            }
            100% { 
                transform: scale(2) rotate(0deg);
                opacity: 0;
            }
        }
        
        @keyframes damageFloat {
            0% {
                transform: translateY(0px);
                opacity: 1;
            }
            100% {
                transform: translateY(-30px);
                opacity: 0;
            }
        }
        
        #controlArea {
            width: 100%;
            height: 35%;
            background: #444;
            position: absolute;
            bottom: 0;
            touch-action: none;
            border-top: 2px solid #665;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            color: #ccc;
            z-index: 250;
        }
        
        #ui {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 250;
            background: rgba(0,0,0,0.8);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            border: 1px solid #665;
            pointer-events: none;
        }
        
        #timer {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 250;
            background: rgba(255,0,0,0.8);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: bold;
            border: 1px solid #665;
            pointer-events: none;
        }

        #deathCounter {
    position: fixed;
    top: 10px;
    right: 90px;
    z-index: 250;
    background: rgba(128,0,128,0.8);
    padding: 8px 12px;
    border-radius: 8px;
    font-size: 12px;
    font-weight: bold;
    border: 1px solid #665;
    pointer-events: none;
}
        
        .maze-wall {
            position: absolute;
            border: 1px solid rgba(0,0,0,0.3);
            filter: brightness(0.6) desaturate(0.3);
        }
        
        .tree-wall {
            position: absolute;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 30;
            filter: grayscale(0.8) brightness(0.7);
        }
        
        .enemy {
            position: absolute;
            width: 22px;
            height: 22px;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }
        
        .enemy.defeated {
            opacity: 0.3;
            filter: grayscale(100%);
        }
        
        .friendly {
            position: absolute;
            width: 22px;
            height: 22px;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 40;
        }
        
        .heart-pickup {
            position: absolute;
            width: 22px;
            height: 22px;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: heartbeat 1s infinite;
            z-index: 60;
        }


        .purple-heart-pickup {
    position: absolute;
    width: 22px;
    height: 22px;
    font-size: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    animation: purpleHeartbeat 1.5s infinite;
    z-index: 60;
}

@keyframes purpleHeartbeat {
    0%, 100% { 
        transform: scale(1);
        filter: drop-shadow(0 0 5px purple);
    }
    50% { 
        transform: scale(1.3);
        filter: drop-shadow(0 0 10px purple) brightness(1.2);
    }
}

.fake-quicksand {
    position: absolute;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background: radial-gradient(circle at center, 
        #8b6914 0%, 
        #a67c1a 30%, 
        #c4941f 60%, 
        #8b6914 100%);
    opacity: 0.98;
    z-index: 80; /* Higher than purple heart */
    animation: quicksandSpin 4s linear infinite;
}
        
        .money-pickup {
            position: absolute;
            width: 22px;
            height: 22px;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: glow 2s infinite;
            z-index: 60;
        }
        
        .exit {
            position: absolute;
            width: 30px;
            height: 30px;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,255,0,0.3);
            border: 2px solid #00ff00;
            border-radius: 6px;
            z-index: 70;
        }
        
        .foreground-enemy {
            position: absolute;
            width: 78px;
            height: 78px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 300;
        }
        
        @keyframes glow {
            0%, 100% { filter: brightness(1) drop-shadow(0 0 5px gold); }
            50% { filter: brightness(1.5) drop-shadow(0 0 10px gold); }
        }
        
        @keyframes heartbeat {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        
        #message {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 400;
            display: none;
            border: 1px solid rgba(255,255,255,0.3);
            max-width: 280px;
            text-align: center;
            backdrop-filter: blur(2px);
            opacity: 0.9;
        }
        
        #startScreen, #levelComplete, #pauseMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 500;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 6px;
            cursor: pointer;
            margin: 8px;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #45a049;
        }
        
        .start-button {
            background: #ff6b35;
            font-size: 18px;
            padding: 15px 30px;
        }
        
        .start-button:hover {
            background: #ff5722;
        }
        
        h2, h3 {
            margin: 10px 0;
        }
        
        .control-hint {
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-size: 12px;
        }


        .quicksand {
    position: absolute;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background: radial-gradient(circle at center, 
        #8b6914 0%, 
        #a67c1a 30%, 
        #c4941f 60%, 
        #8b6914 100%);
    opacity: 0.98;
    z-index: 26;
    animation: quicksandSpin 4s linear infinite;
}

@keyframes quicksandSpin {
    0% { 
        background: radial-gradient(circle at center, 
            #8b6914 0%, 
            #a67c1a 30%, 
            #c4941f 60%, 
            #8b6914 100%);
    }
    50% {
        background: radial-gradient(circle at center, 
            #a67c1a 0%, 
            #c4941f 30%, 
            #8b6914 60%, 
            #a67c1a 100%);
    }
    100% { 
        background: radial-gradient(circle at center, 
            #8b6914 0%, 
            #a67c1a 30%, 
            #c4941f 60%, 
            #8b6914 100%);
    }
}


        @keyframes gunPulsate {
    0%, 100% { 
        transform: scale(1);
    }
    50% { 
        transform: scale(1.2);
    }
}

  
    </style>
</head>
<body>
    <!-- Post-apocalyptic fog overlay -->
    
    <div id="gameContainer">
        <div id="ui">
            <div>üê∏ Post-Apocalyptic Frog</div>
            <div>‚ù§Ô∏è <span id="hearts">3</span></div>
            <div>üí∞ <span id="money">0</span>¬•</div>
        </div>
        <div id="timer">0:00</div>
        <div id="deathCounter">‚ò†Ô∏è0</div>
        <button id="pauseBtn" onclick="pauseGame()" style="position: fixed; top: 10px; right: 160px; z-index: 250; background: rgba(100,0,100,0.8); color: white; border: none; padding: 4px 8px; border-radius: 4px; font-size: 10px; cursor: pointer;">‚è∏Ô∏è</button>
        
        <div id="gameArea">
            <div id="gameWorld">
                <div id="player"></div>
                <div class="apocalypse-overlay"></div>
                <div class="apocalypse-overlay-fast"></div> <!-- ADD THIS LINE -->
            </div>
        </div>
        <div id="message"></div>


        <div id="confirmDialog" style="display: none;">
  <div style="background: rgba(0,0,0,0.9); color: white; padding: 20px; border-radius: 10px; text-align: center;">
    <p id="confirmText">üå≥Ê£Æ„Å´ÂÖ•„Çãüå≥...</p>
    <button onclick="confirmAction()" style="background: #4CAF50; color: white; border: none; padding: 10px 20px; border-radius: 5px;">OK</button>
  </div>
</div>

<!-- Forest overlay and vision mask -->
<div id="forestOverlay" class="forest-overlay"></div>
<div id="forestVisionMask" class="forest-vision-mask"></div>
        
        
        <div id="controlArea">
            <div style="text-align: center; margin-bottom: 10px;">
                <div style="font-size: 18px; font-weight: bold;">üê∏ Post-Apocalyptic World</div>
                <div style="font-size: 12px; opacity: 0.8;">üéÆ Swipe to move, double-tap to shoot!</div>
            </div>
            <div class="control-hint">
                <div>üî´ The world has changed... use your TNT gun wisely!</div>
                <div style="font-size: 11px; opacity: 0.7; margin-top: 5px;">Enemies are stronger but beatable now!</div>
            </div>
        </div>
        
        <div id="startScreen">
            <h2>üê∏ Post-Apocalyptic World</h2>
            <div id="welcomeMessage" style="margin: 20px 0;">The world has been destroyed...</div>
            <p style="font-size: 12px; opacity: 0.8;">üî´ You now have a TNT gun! Double-tap to shoot enemies!</p>
            <button class="start-button" onclick="startGame()">Enter the Wasteland</button>
            <button class="new-game-button" onclick="resetAllProgress()" style="background: #665; font-size: 12px; padding: 8px 16px; opacity: 0.7;">Reset All Progress</button>
        </div>
        
        <div id="levelComplete" style="display: none;">
            <h3 id="levelCompleteTitle">Level Complete!</h3>
            <p id="levelCompleteText">Great job!</p>
            <button id="retryButton" onclick="restartGame()">Play Again</button>
        </div>
        
        <div id="pauseMenu" style="display: none;">
            <h3>‚è∏Ô∏è Game Paused</h3>
            <p style="margin: 20px 0; opacity: 0.8;">Your progress is automatically saved</p>
            <button onclick="resumeGame()">Continue Game</button>
            <button onclick="returnToTitle()">Return to Title</button>
        </div>
    </div>

    <audio id="bgMusic" loop>
        <source src="https://raw.githubusercontent.com/TheDepression/Sounds/main/darkmaze.mp3" type="audio/mp3">
        Your browser does not support the audio element.
    </audio>
<audio id="forestMusic" loop>
    <source src="https://raw.githubusercontent.com/TheDepression/Sounds/main/m2.m4a" type="audio/mp4">
    Your browser does not support the audio element.
</audio>
    <script>
        // CHECK ACCESS AND VALIDATE ENTRY - CRITICAL FIRST
        window.addEventListener('DOMContentLoaded', function() {
            const savedState = localStorage.getItem('mfGameState');
            
            if (!savedState) {
                alert('No game data found! Returning to main world.');
                window.location.href = 'https://thedepression.github.io/games/minimaze/maze1';
                return;
            }
            
            const gameState = JSON.parse(savedState);
            
            // Check if they defeated the pyramid boss
            if (!gameState.pyramidBossDefeated) {
                alert('You must defeat the pyramid boss first!');
                window.location.href = 'https://thedepression.github.io/games/minimaze/maze1';
                return;
            }
            
            // Check if they're coming from cutscene1
            //if (gameState.currentUrl !== 'cutscene1') {
                //alert('Invalid access! Redirecting to proper location.');
              //  window.location.href = 'https://thedepression.github.io/games/minimaze/maze1';
            //    return;
      //      }


            // Check if returning from pink boss fight
if (gameState.currentUrl === 'pinkBoss' && gameState.pinkBossDefeated) {
    // Player completed the pink boss, update the flag
    gameState.currentUrl = 'maze2';
    localStorage.setItem('mfGameState', JSON.stringify(gameState));
}
            
            // Set welcome message
            const playerName = localStorage.getItem('mfPlayerName') || 'Unknown Hero';
            document.getElementById('welcomeMessage').textContent = `The world is destroyed, ${playerName}...`;
        });



// Add opacity for small screens
        if (window.innerHeight <= 667) {
            const style = document.createElement('style');
            style.textContent = `
                #ui, #timer, #deathCounter, #pauseBtn {
                    opacity: 0.6 !important;
                }
               #ui:hover, #timer:hover, #deathCounter:hover, #pauseBtn:hover {
                    opacity: 1 !important;
                    transition: opacity 0.2s ease;
                }
            `;
            document.head.appendChild(style);
        }

        
        class MazeGame {
            constructor() {
                // Basic properties first
                this.collectedRedHearts = []; // Track which red hearts have been collected
                this.collectedMoney = []; // Track which money has been collected
                this.currentMessageType = null; // Track what type of message is showing
                this.collectedBanana = false; // Track if banana has been collected
                this.gorillaEncounterComplete = false; // Track if gorilla encounter is done
                this.pinkBossDefeated = false;
                // Add these after existing properties in constructor
this.hasHammerPower = false; // Track if gun has hammer power upgrade
this.gorillaHammerDialogComplete = false; // Track if hammer dialog is done
this.catFirstDialogComplete = false; // Track if cat's first dialog is done
this.weakPointsBlasted = []; // Track which weak points have been blasted open
this.hasOrangePower = false; // Track if player has orange power upgrade
this.gorillaDialogStep = 0; // Track which dialog step we're on
                this.hearts = 3;
                this.gameStarted = false;
                this.timeElapsed = 0;
                this.deathCount = 0;
                this.timerInterval = null;
                this.isInvulnerable = false;
                this.money = 0;
                this.isPaused = false;

                this.lastTapX = null;
this.lastTapY = null;

                // Add these to constructor after existing properties
this.isInForest = false;
this.forestMusic = document.getElementById('forestMusic');
this.pendingAction = null;

                // Add these after existing properties in constructor
this.maxHearts = 3; // Starting max hearts
this.collectedPurpleHearts = []; // Track which purple hearts have been collected

                
                // FORCE DEFAULT ITEMS (all from maze1 except specified)
                this.hasKey = false;
                this.hasBoat = true;
                this.boatIsBroken = true;
                this.hasHammer = false; // lost it and must find a new one
                this.hasFlashlight = true;
                this.hasPencil = false;
                this.hasPyramidKey = true;
                this.hasTrophy = false;
                // Shop purchases from shop
// this.purpleHeartsSold = 0; // Track how many purple hearts were sold in shop
this.hasSuperGun = false;
this.hasEnhancedRange = false;
this.hasSuperGunTicket = false; // You already have this one
                this.hasLavaShoes = true; 
                this.hasWeapon = true; // ALWAYS have gun
                this.bullyDefeated = true;
                this.motherPaid = true;
                this.caveBossDefeated = true;
                this.pyramidBossDefeated = true;
                
                // Gun system from pyramid boss
                this.attackCooldown = false;
                this.attackRange = 45;
               this.attackDamage = 50; // Will be 100 with orange power
                this.lastTap = 0;
                this.tapDelay = 300;
                
                // Movement properties
                this.playerX = 400;
                this.playerY = 1760;
                this.playerVelocityX = 0;
                this.playerVelocityY = 0;
                this.isDragging = false;
                this.lastDragX = 0;
                this.lastDragY = 0;
                this.currentDirection = 's';
                this.lastMoveDirection = 's';

              
    this.sinkingInQuicksand = false;
    this.quicksandStrength = 0; // How strong the pull is
    this.quicksandCenter = null; // Which quicksand pit center

                // Add these after existing properties in constructor
this.wasOnLava = false;
this.lavaProtectionTime = 5; // Start with full protection
this.lavaProtectionActive = false;
this.lastLavaZoneTime = 0;
this.lastLavaDamage = 0;
                
                // Enemy and interaction properties
                this.movingEnemies = [];
                this.foregroundEnemy = null;
                this.lastForegroundSpawn = Date.now();
                this.lastInteractionTime = {};
                this.recentlyDied = false;
                
                // DOM elements
                this.player = document.getElementById('player');
                this.gameWorld = document.getElementById('gameWorld');
                this.gameArea = document.getElementById('gameArea');
                this.controlArea = document.getElementById('controlArea');
                this.bgMusic = document.getElementById('bgMusic');

        
                
                // Initialize
                this.preloadPlayerImages();
                this.bindEvents();
                this.loadGameState();
                this.startGameLoop();
            }

            preloadPlayerImages() {
                const directions = ['n', 'ne', 'e', 'se', 's', 'sw', 'w', 'nw'];
                this.playerImages = {};
                
                directions.forEach(direction => {
                    const img = new Image();
                    img.src = `https://raw.githubusercontent.com/TheDepression/Photos/main/${direction}.PNG`;
                    this.playerImages[direction] = img;
                });
            }

            bindEvents() {
                this.controlArea.addEventListener('touchstart', (e) => this.handleStart(e), {passive: false});
                this.controlArea.addEventListener('touchmove', (e) => this.handleMove(e), {passive: false});
                this.controlArea.addEventListener('touchend', (e) => this.handleEnd(e), {passive: false});
                
                this.controlArea.addEventListener('mousedown', (e) => this.handleStart(e));
                this.controlArea.addEventListener('mousemove', (e) => this.handleMove(e));
                this.controlArea.addEventListener('mouseup', (e) => this.handleEnd(e));
                this.controlArea.addEventListener('mouseleave', (e) => this.handleEnd(e));
            }



            enterForest() {
    this.playerVelocityX = 0;
    this.playerVelocityY = 0;
    this.isDragging = false;
    this.gameStarted = false;
    document.getElementById('confirmText').textContent = 'üå≤ Entering the forest...';
    document.getElementById('confirmDialog').style.display = 'flex';
    this.pendingAction = 'enterForest';
}

exitForest() {
    this.playerVelocityX = 0;
    this.playerVelocityY = 0;
    this.isDragging = false;
    this.gameStarted = false;
    document.getElementById('confirmText').textContent = 'üåû Leaving the forest!';
    document.getElementById('confirmDialog').style.display = 'flex';
    this.pendingAction = 'exitForest';
}

updateForestVisibility() {
    const forestZones = this.gameWorld.querySelectorAll('[data-zone-type="forest"]');
    const walls = this.gameWorld.querySelectorAll('.maze-wall, .tree-wall, .enemy, .friendly, .breakable-wall, .tiled-wall, .money-pickup, .heart-pickup, .purple-heart-pickup, .exit');
    
    // First, reset all walls to visible
    walls.forEach(wall => {
        wall.style.visibility = 'visible';
    });
    
    // Then hide forest walls if not in forest
    walls.forEach(wall => {
        let inForest = false;
        const wallX = parseInt(wall.style.left) + 10;
        const wallY = parseInt(wall.style.top) + 10;
        
        forestZones.forEach(zone => {
            const zoneLeft = parseInt(zone.style.left);
            const zoneTop = parseInt(zone.style.top);
            const zoneRight = zoneLeft + parseInt(zone.style.width);
            const zoneBottom = zoneTop + parseInt(zone.style.height);
            
            if (wallX >= zoneLeft && wallX <= zoneRight && 
                wallY >= zoneTop && wallY <= zoneBottom) {
                inForest = true;
            }
        });
        
        if (inForest) {
            wall.style.visibility = this.isInForest ? 'visible' : 'hidden';
        }
    });
}

initializeZoneEffects() {
    const playerCenterX = this.playerX + 12;
    const playerCenterY = this.playerY + 12;
    
    // Check if spawning in forest
    const forestZones = this.gameWorld.querySelectorAll('[data-zone-type="forest"]');
    let inForest = false;
    
    for (let zone of forestZones) {
        const zoneRect = {
            left: parseInt(zone.style.left),
            top: parseInt(zone.style.top),
            right: parseInt(zone.style.left) + parseInt(zone.style.width),
            bottom: parseInt(zone.style.top) + parseInt(zone.style.height)
        };
        
        if (playerCenterX >= zoneRect.left && playerCenterX <= zoneRect.right &&
            playerCenterY >= zoneRect.top && playerCenterY <= zoneRect.bottom) {
            inForest = true;
            break;
        }
    }
    
    if (inForest) {
        this.isInForest = true;
        this.bgMusic.pause();
        this.bgMusic.currentTime = 0;
        this.bgMusic.volume = 0;
        this.forestMusic.currentTime = 0;
        this.forestMusic.play().catch(e => console.log('Forest music play failed:', e));
        document.getElementById('forestOverlay').classList.add('active');
        document.getElementById('forestVisionMask').classList.add('active');
        this.updateForestVisibility();
        
        const gameAreaRect = this.gameArea.getBoundingClientRect();
        const playerScreenX = gameAreaRect.left + (this.gameArea.offsetWidth / 2);
        const playerScreenY = gameAreaRect.top + (this.gameArea.offsetHeight / 2);
        const mask = document.getElementById('forestVisionMask');
        mask.style.background = `radial-gradient(circle 111px at ${playerScreenX}px ${playerScreenY}px, transparent 111px, black 111px)`;
    } else {
        this.isInForest = false;
        this.forestMusic.pause();
        this.bgMusic.play().catch(e => console.log('Music play failed:', e));
        document.getElementById('forestOverlay').classList.remove('active');
        document.getElementById('forestVisionMask').classList.remove('active');
        this.updateForestVisibility();
    }
}

canGorillaMoveTo(x, y) {
    const gorillaSize = 33;
    const padding = 2;
    
    const points = [
        {x: x + padding, y: y + padding},
        {x: x + gorillaSize - padding, y: y + padding},
        {x: x + padding, y: y + gorillaSize - padding},
        {x: x + gorillaSize - padding, y: y + gorillaSize - padding}
    ];
    
    const walls = this.gameWorld.querySelectorAll('.maze-wall, .tree-wall, .breakable-wall, .tiled-wall');
    
    for (let wall of walls) {
        const wallRect = {
            left: parseInt(wall.style.left),
            top: parseInt(wall.style.top),
            right: parseInt(wall.style.left) + (parseInt(wall.style.width) || 20),
            bottom: parseInt(wall.style.top) + (parseInt(wall.style.height) || 20)
        };
        
        for (let point of points) {
            if (point.x >= wallRect.left && point.x <= wallRect.right &&
                point.y >= wallRect.top && point.y <= wallRect.bottom) {
                return false;
            }
        }
    }
    
    return true;
}

            handleStart(e) {
    if (!this.gameStarted) return;
    e.preventDefault();
    
    // Stricter double-tap for attack
    const now = Date.now();
    const point = e.touches ? e.touches[0] : e;
    const currentX = point.clientX;
    const currentY = point.clientY;
    
    if (this.hasWeapon && now - this.lastTap < 250 && !this.attackCooldown) { // Reduced from 300ms to 250ms
        // Check if taps are in similar location (within 30px)
        if (this.lastTapX && this.lastTapY) {
            const tapDistance = Math.sqrt(
                Math.pow(currentX - this.lastTapX, 2) + 
                Math.pow(currentY - this.lastTapY, 2)
            );
            
            if (tapDistance < 30) { // Must be within 30px of first tap
                this.attack();
                this.lastTap = 0;
                this.lastTapX = null;
                this.lastTapY = null;
                return;
            }
        }
    }
    
    // Store tap info for next potential double-tap
    this.lastTap = now;
    this.lastTapX = currentX;
    this.lastTapY = currentY;
    
    this.isDragging = true;
    this.lastDragX = currentX;
    this.lastDragY = currentY;
}
            
            handleMove(e) {
                if (!this.isDragging || !this.gameStarted) return;
                e.preventDefault();
                
                const point = e.touches ? e.touches[0] : e;
                const deltaX = point.clientX - this.lastDragX;
                const deltaY = point.clientY - this.lastDragY;

                if (Math.abs(deltaX) > 1.2 || Math.abs(deltaY) > 1.2) {
                    const newDirection = this.getDirectionFromMovement(deltaX, deltaY);
                    if (newDirection !== this.currentDirection) {
                        this.updatePlayerImage(newDirection);
                        this.lastMoveDirection = newDirection;
                    }
                }

                const baseSensitivity = 0.5;
const sensitivity = this.isOnDesert ? baseSensitivity * 0.25 : baseSensitivity;
this.playerVelocityX = deltaX * sensitivity;
this.playerVelocityY = deltaY * sensitivity;

                const maxVelocity = 11;
                this.playerVelocityX = Math.max(-maxVelocity, Math.min(maxVelocity, this.playerVelocityX));
                this.playerVelocityY = Math.max(-maxVelocity, Math.min(maxVelocity, this.playerVelocityY));
                
                this.lastDragX = point.clientX;
                this.lastDragY = point.clientY;
            }
            
            handleEnd(e) {
                this.isDragging = false;
                this.playerVelocityX = 0;
                this.playerVelocityY = 0;
            }

            getDirectionFromMovement(deltaX, deltaY) {
                let angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
                if (angle < 0) angle += 360;
                
                if (angle >= 337.5 || angle < 22.5) return 'e';
                else if (angle >= 22.5 && angle < 67.5) return 'se';  
                else if (angle >= 67.5 && angle < 112.5) return 's';
                else if (angle >= 112.5 && angle < 157.5) return 'sw';
                else if (angle >= 157.5 && angle < 202.5) return 'w';
                else if (angle >= 202.5 && angle < 247.5) return 'nw';
                else if (angle >= 247.5 && angle < 292.5) return 'n';
                else return 'ne';
            }

            updatePlayerImage(direction) {
                this.currentDirection = direction;
                this.player.style.backgroundImage = `url("https://raw.githubusercontent.com/TheDepression/Photos/main/${direction}.PNG")`;
                this.player.textContent = '';
            }

           attack() {
    if (!this.hasWeapon) return;
    
    this.attackCooldown = true;
    
    const attackEl = document.createElement('div');
    attackEl.style.position = 'absolute';
    attackEl.style.pointerEvents = 'none';
    attackEl.style.zIndex = '400';
    attackEl.style.animation = 'slashEffect 0.3s ease-out';
    
    // Enhanced range: make everything 50% bigger
    if (this.hasEnhancedRange) {
        attackEl.style.width = '60px';  // 40px * 1.5
        attackEl.style.height = '60px'; // 40px * 1.5
    } else {
        attackEl.style.width = '40px';
        attackEl.style.height = '40px';
    }
    
    attackEl.style.background = 'radial-gradient(circle, rgba(255,255,0,0.8) 0%, rgba(255,0,0,0.4) 70%, transparent 100%)';
    attackEl.style.borderRadius = '50%';
    
    const directionOffsets = {
        'n': {x: 0, y: -35},    // Further away from player
        'ne': {x: 25, y: -25},
        'e': {x: 35, y: 0},
        'se': {x: 25, y: 25},
        's': {x: 0, y: 35},
        'sw': {x: -25, y: 25},
        'w': {x: -35, y: 0},
        'nw': {x: -25, y: -25}
    };
    
    const offset = directionOffsets[this.currentDirection];
    // Better centering - adjust for circle size
    const visualCenterX = this.hasEnhancedRange ? 30 : 20;
    const visualCenterY = this.hasEnhancedRange ? 30 : 20;
    
    attackEl.style.left = (this.playerX + offset.x - visualCenterX + 12) + 'px';
    attackEl.style.top = (this.playerY + offset.y - visualCenterY + 12) + 'px';
    
    this.gameWorld.appendChild(attackEl);
    
    setTimeout(() => {
        if (attackEl.parentNode) {
            attackEl.remove();
        }
    }, 300);
    
    this.checkAttackHits(this.playerX + offset.x, this.playerY + offset.y);
    
    setTimeout(() => {
        this.attackCooldown = false;
    }, 500);
}



           checkAttackHits(attackX, attackY) {
    // Set range from PLAYER position, not attack position
    const effectiveRange = this.hasEnhancedRange ? 90 : 45;
    
    // Check weak points (only if has hammer power)
    if (this.hasHammerPower) {
        const weakPoints = this.gameWorld.querySelectorAll('.weak-point');
        weakPoints.forEach(weakPoint => {
            const weakX = parseInt(weakPoint.style.left) + 10;
            const weakY = parseInt(weakPoint.style.top) + 10;
            
            // Check if target is in front of player
            const deltaX = weakX - this.playerX;
            const deltaY = weakY - this.playerY;
            const directionCheck = this.isInFrontOfPlayer(deltaX, deltaY);
            
            if (directionCheck) {
                // Calculate distance from PLAYER, not attack point
                const distance = Math.sqrt(
                    Math.pow(this.playerX - weakX, 2) +
                    Math.pow(this.playerY - weakY, 2)
                );
                
                if (distance <= effectiveRange) {
                    const weakId = weakPoint.dataset.id;
                    const weakUrl = weakPoint.dataset.url;
                    
                    this.weakPointsBlasted.push(weakId);
                    this.saveGameState();
                    
                    weakPoint.remove();
                    
                    const entrance = document.createElement('div');
                    entrance.className = 'weak-point-entrance';
                    entrance.style.position = 'absolute';
                    entrance.style.left = (weakX - 10) + 'px';
                    entrance.style.top = (weakY - 10) + 'px';
                    entrance.style.width = '20px';
                    entrance.style.height = '20px';
                    entrance.style.background = 'black';
                    entrance.style.border = '1px solid #333';
                    entrance.style.zIndex = '200';
                    entrance.dataset.url = weakUrl;
                    entrance.dataset.type = 'weakPointEntrance';
                    this.gameWorld.appendChild(entrance);
                    
                    this.showMessage('üí• Weak point blasted open!');
                }
            }
        });
    }
    
    // Check breakable walls (with hammer power)
    if (this.hasHammerPower) {
        const breakableWalls = this.gameWorld.querySelectorAll('.breakable-wall');
        breakableWalls.forEach(wall => {
            const wallX = parseInt(wall.style.left) + parseInt(wall.style.width)/2;
            const wallY = parseInt(wall.style.top) + parseInt(wall.style.height)/2;
            
            // Check if target is in front of player
            const deltaX = wallX - this.playerX;
            const deltaY = wallY - this.playerY;
            const directionCheck = this.isInFrontOfPlayer(deltaX, deltaY);
            
            if (directionCheck) {
                const distance = Math.sqrt(
                    Math.pow(attackX - wallX, 2) +
                    Math.pow(attackY - wallY, 2)
                );
                
                if (distance <= effectiveRange) {
                    this.showMessage('üî´üî® *BLAST* Wall destroyed!');
                    wall.remove();
                }
            }
        });
    }
    
    // Check enemies
    this.movingEnemies.forEach(enemy => {
        if (!enemy.alive || enemy.type === 'gorilla') return;
        
        // Check if target is in front of player
        const deltaX = enemy.currentX - this.playerX;
        const deltaY = enemy.currentY - this.playerY;
        const directionCheck = this.isInFrontOfPlayer(deltaX, deltaY);
        
        if (directionCheck) {
            const distance = Math.sqrt(
                Math.pow(attackX - enemy.currentX, 2) +
                Math.pow(attackY - enemy.currentY, 2)
            );
            
            if (distance <= effectiveRange) {
                enemy.hp -= this.attackDamage;
                
                const damageText = document.createElement('div');
                damageText.style.position = 'absolute';
                damageText.style.color = '#ff4444';
                damageText.style.fontWeight = 'bold';
                damageText.style.fontSize = '14px';
                damageText.style.pointerEvents = 'none';
                damageText.style.zIndex = '500';
                damageText.style.animation = 'damageFloat 1s ease-out';
                damageText.textContent = `-${this.attackDamage}`;
                damageText.style.left = enemy.currentX + 'px';
                damageText.style.top = enemy.currentY + 'px';
                this.gameWorld.appendChild(damageText);
                
                setTimeout(() => {
                    if (damageText.parentNode) {
                        damageText.remove();
                    }
                }, 1000);
                
                if (enemy.hp <= 0) {
                    enemy.alive = false;
                    enemy.element.classList.add('defeated');
                    
                    if (Math.random() < 0.15) {
                        this.createMoneyDrop(enemy.currentX, enemy.currentY);
                    }
                    if (Math.random() < 0.10) {
                        this.createHeartDrop(enemy.currentX, enemy.currentY);
                    }
                }
            }
        }
    });

    // Check gorilla collision for attack (but don't damage)
    if (this.gorilla && this.gorilla.alive) {
        // Check if target is in front of player
        const deltaX = this.gorilla.currentX - this.playerX;
        const deltaY = this.gorilla.currentY - this.playerY;
        const directionCheck = this.isInFrontOfPlayer(deltaX, deltaY);
        
        if (directionCheck) {
            const distance = Math.sqrt(
                Math.pow(attackX - this.gorilla.currentX, 2) +
                Math.pow(attackY - this.gorilla.currentY, 2)
            );
            
            if (distance <= effectiveRange) {
                this.showMessage('ü¶ç The gorilla seems friendly now...');
            }
        }
    }
}


            isInFrontOfPlayer(deltaX, deltaY) {
    // Only hit targets in the front 180 degrees based on facing direction
    switch(this.currentDirection) {
        case 'n': return deltaY < 0;
        case 'ne': return deltaX > 0 && deltaY < 0;
        case 'e': return deltaX > 0;
        case 'se': return deltaX > 0 && deltaY > 0;
        case 's': return deltaY > 0;
        case 'sw': return deltaX < 0 && deltaY > 0;
        case 'w': return deltaX < 0;
        case 'nw': return deltaX < 0 && deltaY < 0;
        default: return true;
    }
}

           

            createMoneyDrop(x, y) {
                const money = document.createElement('div');
                money.className = 'money-pickup';
                money.textContent = 'üí∞';
                money.style.left = x + 'px';
                money.style.top = y + 'px';
                money.dataset.value = '100';
                money.dataset.type = 'drop';
                this.gameWorld.appendChild(money);
            }

            createHeartDrop(x, y) {
                const heart = document.createElement('div');
                heart.className = 'heart-pickup';
                heart.textContent = '‚ù§Ô∏è';
                heart.style.left = x + 'px';
                heart.style.top = y + 'px';
                heart.dataset.type = 'drop';
                this.gameWorld.appendChild(heart);
            }

            loadGameState() {
    const savedState = localStorage.getItem('mfGameState');
    if (savedState) {
        const gameState = JSON.parse(savedState);
        this.collectedBanana = gameState.collectedBanana || false;
        this.hasSuperGunTicket = gameState.hasSuperGunTicket || false;
        // Add this to maze2's loadGameState() function:
this.cdmoney1 = gameState.cdmoney1 || false;
this.cdmoney2 = gameState.cdmoney2 || false;
this.cdmoney3 = gameState.cdmoney3 || false;
this.cdmoney4 = gameState.cdmoney4 || false;
this.cdmoney5 = gameState.cdmoney5 || false;
this.cdmoneyEntrance = gameState.cdmoneyEntrance || false;
this.cdpheart1 = gameState.cdpheart1 || false;
this.cdpheart2 = gameState.cdpheart2 || false;
        
        // Load shop purchases
     //   this.purpleHeartsSold = gameState.purpleHeartsSold || 0;
        this.hasSuperGun = gameState.hasSuperGun || false;
        this.hasEnhancedRange = gameState.hasEnhancedRange || false;
        
        this.hasKey = gameState.hasKey || false;
        
        this.gorillaEncounterComplete = gameState.gorillaEncounterComplete || false;
        this.hasOrangePower = gameState.hasOrangePower || false;
        this.pinkBossDefeated = gameState.pinkBossDefeated || false;
        this.hasHammerPower = gameState.hasHammerPower || false;
        this.gorillaHammerDialogComplete = gameState.gorillaHammerDialogComplete || false;
        this.catFirstDialogComplete = gameState.catFirstDialogComplete || false;
        this.weakPointsBlasted = gameState.weakPointsBlasted || [];
        this.hasTrophy = gameState.hasTrophy || false;
        this.kingMoneyReceived = gameState.kingMoneyReceived || false;
        this.collectedRedHearts = gameState.collectedRedHearts || [];
        this.collectedMoney = gameState.collectedMoney || [];
        this.hearts = gameState.hearts || 3;
        this.money = gameState.money || 0;
        this.timeElapsed = gameState.timeElapsed || 0;
        this.deathCount = gameState.deathCount || 0;
        this.updateDeathCounter();
        this.playerX = gameState.playerX || 400;
        this.playerY = gameState.playerY || 1760;
        this.maxHearts = gameState.maxHearts || 3;
        this.collectedPurpleHearts = gameState.collectedPurpleHearts || [];
        this.hasBoat = true;
        this.boatIsBroken = gameState.boatIsBroken !== undefined ? gameState.boatIsBroken : true;
        
        // Apply ALL damage upgrades in the correct priority order (ONLY ONCE, AT THE END)
        if (this.hasSuperGun) {
            this.attackDamage = 150; // Super gun has highest priority
        } else if (this.hasOrangePower || this.hasHammerPower) {
            this.attackDamage = 100; // Orange power OR hammer power
        } else {
            this.attackDamage = 50; // Base damage
        }
        
        // Apply range upgrade
        if (this.hasEnhancedRange) {
            this.attackRange = 90; // Double the range from 45 to 90
        }
        
        // Apply max hearts from shop purple hearts
     //   this.maxHearts += this.purpleHeartsSold;
        
        this.updateTimer();
        return true;
    }
    return false;
}

            saveGameState() {
                const gameState = {
                    collectedRedHearts: this.collectedRedHearts,
                    collectedMoney: this.collectedMoney,
                    hearts: this.hearts,
                    money: this.money,
                    timeElapsed: this.timeElapsed,
                     deathCount: this.deathCount, // ADD THIS LINE
                    kingMoneyReceived: this.kingMoneyReceived,  // ADD THIS

                    // Add these lines in saveGameState() after existing properties
maxHearts: this.maxHearts,
collectedPurpleHearts: this.collectedPurpleHearts,
                    collectedBanana: this.collectedBanana,
                    hasTrophy: this.hasTrophy,
                    gorillaEncounterComplete: this.gorillaEncounterComplete,
hasOrangePower: this.hasOrangePower,
                    attackDamage: this.attackDamage,
                    hasSuperGunTicket: this.hasSuperGunTicket,
                    cdmoney1: this.cdmoney1,
cdmoney2: this.cdmoney2,
cdmoney3: this.cdmoney3,
cdmoney4: this.cdmoney4,
cdmoney5: this.cdmoney5,
cdmoneyEntrance: this.cdmoneyEntrance,
cdpheart1: this.cdpheart1,
cdpheart2: this.cdpheart2,
                    // Add these lines in saveGameState() after existing properties
// purpleHeartsSold: this.purpleHeartsSold,
hasSuperGun: this.hasSuperGun,
hasEnhancedRange: this.hasEnhancedRange,
                    pinkBossDefeated: this.pinkBossDefeated,
                    // Add these lines in saveGameState() after existing properties
hasHammerPower: this.hasHammerPower,
gorillaHammerDialogComplete: this.gorillaHammerDialogComplete,
catFirstDialogComplete: this.catFirstDialogComplete,
weakPointsBlasted: this.weakPointsBlasted,
                    
                    
                    playerX: this.playerX,
                    playerY: this.playerY,
                   
                    hasBoat: true,
        boatIsBroken: this.boatIsBroken, // ADD THIS
                  
                    hasFlashlight: true,
                 hasKey: this.hasKey,
                    hasPyramidKey: true,
                    hasLavaShoes: true,
                    hasWeapon: true,
                    bullyDefeated: true,
                    motherPaid: true,
                    caveBossDefeated: true,
                    pyramidBossDefeated: true,
                    currentUrl: 'maze2',
                    lastSaveTime: Date.now()
                };
                localStorage.setItem('mfGameState', JSON.stringify(gameState));
            }

            startGameTimer() {
                this.gameStarted = true;
                this.updateTimer();
                this.bgMusic.play().catch(e => console.log('Music play failed:', e));
                
                this.timerInterval = setInterval(() => {
                    if (!this.isPaused) {
                        this.timeElapsed++;
                        this.updateTimer();
                        
                        // Auto-save every minute
                        if (this.timeElapsed % 60 === 0) {
                            this.saveGameState();
                        }

                        // Respawn enemies every 5 minutes (if not recently died)
                        if (this.timeElapsed % 300 === 0 && !this.recentlyDied) {
                            this.respawnEnemies();
                        }
                    }
                }, 1000);
            }

            respawnEnemies() {
                // Remove defeated enemies and respawn them
                this.movingEnemies.forEach(enemy => {
                    if (!enemy.alive) {
                        enemy.alive = true;
                        enemy.hp = enemy.maxHp;
                        enemy.element.classList.remove('defeated');
                    }
                });
                this.showMessage('üë∫„Å¶„Åç„Åå Êàª„Å£„Å¶Êù•„ÅüüîÑ ');
            }
            
            updateTimer() {
                const minutes = Math.floor(this.timeElapsed / 60);
                const seconds = this.timeElapsed % 60;
                const timerEl = document.getElementById('timer');
                timerEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                if (this.timeElapsed >= 600) {
                    timerEl.style.background = 'rgba(255,0,0,0.8)';
                } else if (this.timeElapsed >= 300) {
                    timerEl.style.background = 'rgba(255,165,0,0.8)';
                } else {
                    timerEl.style.background = 'rgba(0,128,0,0.8)';
                }
            }

            updateDeathCounter() {
    document.getElementById('deathCounter').textContent = `‚ò†Ô∏è${this.deathCount}`;
}

            initLevel() {
                // Clear existing elements debido below
                const elements = this.gameWorld.querySelectorAll('.maze-wall, .tree-wall, .breakable-wall, .enemy, .friendly, .heart-pickup, .money-pickup, .exit, .foreground-enemy, .water-zone, .forest-zone, .desert-zone, .grass-zone, .lava-zone, .gorilla-encounter, .gorilla-friend, .forest-gorilla');
                elements.forEach(el => el.remove());
                
                this.movingEnemies = [];
                this.foregroundEnemy = null;
                this.gorilla = null;  // Clear gorilla reference debido
                this.lastForegroundSpawn = Date.now();
                this.lastInteractionTime = {};
                
                this.updateUI();
                this.generateMaze();
                this.createEmojiWalls(); // ADD THIS LINE
                this.createFakeTiledWalls(); // ADD THIS LINE

                this.createCollectibles();
                this.createMoneyCollectibles(); // ADD THIS LINE
this.createPurpleHearts();
                this.createBanana();
                this.createWeakPoints(); // Add this line after createBanana()
                
                // Center camera on player
                const gameAreaWidth = this.gameArea.offsetWidth;
                const gameAreaHeight = this.gameArea.offsetHeight;
                const scrollX = this.playerX - gameAreaWidth / 2 + 12;
                const scrollY = this.playerY - gameAreaHeight / 2 + 12;
                this.gameArea.scrollTo({
                    left: scrollX,
                    top: scrollY,
                    behavior: 'auto'
                });

                // Add this at the end of initLevel()
this.updateForestVisibility();
            }
            
            generateMaze() {
                // Create background zones
                this.createBackgroundZones();
                
                // Create colored walls from the data
                this.createColoredWalls();
                
                // Add tree walls
                this.addTreeWalls();
                
                // Set player position
                const visualOffset = (32 - 24) / 2;
                this.player.style.left = (this.playerX - visualOffset) + 'px';
                this.player.style.top = (this.playerY - visualOffset) + 'px';
                this.updatePlayerImage('s');

                // ADD THE COVER SQUARE HERE:
const coverSquare = document.createElement('div');
coverSquare.className = 'cover-square';
coverSquare.style.position = 'absolute';
coverSquare.style.left = '0px';
coverSquare.style.top = '0px';
coverSquare.style.width = '25px';
coverSquare.style.height = '35px';
coverSquare.style.background = 'black'; // Make it red so we can see it
coverSquare.style.zIndex = '100';
coverSquare.style.pointerEvents = 'none';
this.gameWorld.appendChild(coverSquare);
console.log('Cover square created:', coverSquare); // Debug log
                
                // Create enemies - 30% faster than original
                this.createEnemies();
                
                // Create updated friendlies
                this.createFriendlies();
                
                // Create exit
                this.createExit();
                
                // Create destroyed pyramid hitbox
                this.createDestroyedPyramid();
            }

            createBackgroundZones() {
                // Water zones (same positions, darker aesthetics)
                const waterZones = [
                    {x: 0, y: 0, w: 2120, h: 360},
                    {x: 1900, y: 360, w: 500, h: 640}
                ];

                waterZones.forEach(zone => {
                    const waterZone = document.createElement('div');
                    waterZone.className = 'water-zone';
                    waterZone.style.left = zone.x + 'px';
                    waterZone.style.top = zone.y + 'px';
                    waterZone.style.width = zone.w + 'px';
                    waterZone.style.height = zone.h + 'px';
                    waterZone.dataset.zoneType = 'water';
                    this.gameWorld.appendChild(waterZone);
                });

                // Grass zones
                const grassZones = [
                    {x: 1400, y: 1280, w: 80, h: 80},
                    {x: 2120, y: 0, w: 280, h: 360},
                    {x: 2180, y: 2260, w: 220, h: 140},
                    {x: 1940, y: 2000, w: 135, h: 100},
                    {x: 1600, y: 410, w: 5, h: 50}
                ];

                grassZones.forEach(zone => {
                    const grassZone = document.createElement('div');
                    grassZone.className = 'grass-zone';
                    grassZone.style.left = zone.x + 'px';
                    grassZone.style.top = zone.y + 'px';
                    grassZone.style.width = zone.w + 'px';
                    grassZone.style.height = zone.h + 'px';
                    this.gameWorld.appendChild(grassZone);
                });
              
                // Forest zone
                const forestZone = document.createElement('div');
                forestZone.className = 'forest-zone';
                forestZone.style.left = '600px';
                forestZone.style.top = '360px';
                forestZone.style.width = '1000px';
                forestZone.style.height = '940px';
                forestZone.dataset.zoneType = 'forest';
                this.gameWorld.appendChild(forestZone);
                
                // Lava zones
                const lavaZones = [
                    {x: 1320, y: 1740, w: 280, h: 660},
                    {x: 1600, y: 1740, w: 800, h: 240},
                    {x: 1800, y: 2100, w: 380, h: 160}
                ];

                lavaZones.forEach(zone => {
                    const lavaZone = document.createElement('div');
                    lavaZone.className = 'lava-zone';
                    lavaZone.style.left = zone.x + 'px';
                    lavaZone.style.top = zone.y + 'px';
                    lavaZone.style.width = zone.w + 'px';
                    lavaZone.style.height = zone.h + 'px';
                    lavaZone.dataset.zoneType = 'lava';
                    this.gameWorld.appendChild(lavaZone);
                });

                // Desert zone
                const desertZone = document.createElement('div');
                desertZone.className = 'desert-zone';
                desertZone.style.left = '1600px';
                desertZone.style.top = '1000px';
                desertZone.style.width = '800px';
                desertZone.style.height = '540px';
                desertZone.dataset.zoneType = 'desert';
                this.gameWorld.appendChild(desertZone);


                // Create quicksand pits in desert
const quicksandPositions = [
    {x: 2000, y: 1210},
    {x: 2100, y: 1210},
    {x: 2300, y: 1320},
    {x: 2320, y: 1400},
    {x: 2260, y: 1470},
    {x: 2200, y: 1390},
    {x: 2170, y: 1110},
    {x: 2100, y: 1300},
    {x: 2060, y: 1470},
    {x: 2090, y: 1390},
    {x: 2330, y: 1030},
    {x: 2240, y: 1060}
];

quicksandPositions.forEach(pos => {
    const quicksand = document.createElement('div');
    quicksand.className = 'quicksand';
    quicksand.style.left = pos.x + 'px';
    quicksand.style.top = pos.y + 'px';
    quicksand.dataset.type = 'quicksand';
    this.gameWorld.appendChild(quicksand);
});
                // Village zones
                const villageZones = [
                    {x: 0, y: 580, w: 140, h: 120},
                    {x: 0, y: 1180, w: 500, h: 640}
                ];

                villageZones.forEach(zone => {
                    const villageZone = document.createElement('div');
                    villageZone.className = 'village-zone';
                    villageZone.style.left = zone.x + 'px';
                    villageZone.style.top = zone.y + 'px';
                    villageZone.style.width = zone.w + 'px';
                    villageZone.style.height = zone.h + 'px';
                    villageZone.dataset.zoneType = 'village';
                    this.gameWorld.appendChild(villageZone);
                });

                // Castle zone (destroyed)
                const castleZone = document.createElement('div');
                castleZone.className = 'castle-zone';
                castleZone.style.left = '2190px';
                castleZone.style.top = '70px';
                castleZone.style.width = '150px';
                castleZone.style.height = '240px';
                this.gameWorld.appendChild(castleZone);

                // RPG House for shop
const rpgHouse = document.createElement('div');
rpgHouse.style.position = 'absolute';
rpgHouse.style.left = '2280px';
rpgHouse.style.top = '2220px';
rpgHouse.style.width = '60px';
rpgHouse.style.height = '60px';
rpgHouse.style.backgroundImage = 'url("https://raw.githubusercontent.com/TheDepression/Photos/main/rpghouse-min.png")';
rpgHouse.style.backgroundSize = 'contain';
rpgHouse.style.backgroundRepeat = 'no-repeat';
rpgHouse.style.backgroundPosition = 'center';
rpgHouse.style.zIndex = '35';
rpgHouse.dataset.type = 'rpgHouse';
this.gameWorld.appendChild(rpgHouse);


                // Battle Coliseum (decorative)
const coliseum = document.createElement('div');
coliseum.style.position = 'absolute';
coliseum.style.left = '1960px';
coliseum.style.top = '2020px';
coliseum.style.width = '80px';
coliseum.style.height = '80px';
coliseum.style.backgroundImage = 'url("https://raw.githubusercontent.com/TheDepression/Photos/main/battlezone-min.png")';
coliseum.style.backgroundSize = 'contain';
coliseum.style.backgroundRepeat = 'no-repeat';
coliseum.style.backgroundPosition = 'center';
coliseum.style.zIndex = '35';
this.gameWorld.appendChild(coliseum);

                // Add fake quicksand with hidden purple heart at the end of createBackgroundZones()

// Create fake quicksand (visual only, no collision)
const fakeQuicksand = document.createElement('div');
fakeQuicksand.className = 'fake-quicksand';
fakeQuicksand.style.left = '2260px'; // Center the 60px circle around x:2290
fakeQuicksand.style.top = '1190px'; // Center the 60px circle around y:1220
fakeQuicksand.dataset.type = 'fakeQuicksand';
this.gameWorld.appendChild(fakeQuicksand);
            }

            createColoredWalls() {
    const wallData = {
        black: [
            // Border walls
            {x: 0, y: 0, w: 2400, h: 20},
            {x: 0, y: 0, w: 20, h: 2400},
            {x: 2400, y: 0, w: 20, h: 2400},
            {x: 0, y: 2400, w: 2400, h: 20},
            // Main structure walls
             {x: 140, y: 580, w: 10, h: 120},
  {x: 0, y: 580, w: 140, h: 10},
            {x: 0, y: 1470, w: 180, h: 10},
            {x: 0, y: 1630, w: 180, h: 10},
  {x: 200, y: 1800, w: 300, h: 10},
             {x: 2230, y: 2360, w: 170, h: 10},    // the purple heart store wall
            {x: 2240, y: 2360, w: 10, h: 40},    // DoorA
            {x: 2280, y: 2360, w: 10, h: 40},    // DoorB
            {x: 2320, y: 2360, w: 10, h: 40},    // DoorC
            {x: 2360, y: 2360, w: 10, h: 40},    // DoorD
  {x: 600, y: 360, w: 20, h: 920},
  {x: 600, y: 360, w: 380, h: 20},
  {x: 1580, y: 360, w: 20, h: 40},
  {x: 1580, y: 460, w: 20, h: 840},
  {x: 600, y: 1280, w: 780, h: 20},
  {x: 1500, y: 1280, w: 80, h: 20},
  {x: 1380, y: 1300, w: 20, h: 60},
  {x: 1480, y: 1300, w: 20, h: 60},
  {x: 2190, y: 60, w: 20, h: 240},
  {x: 2190, y: 60, w: 150, h: 30},
  {x: 2340, y: 60, w: 20, h: 240},
  {x: 2190, y: 270, w: 55, h: 30},
  {x: 2300, y: 270, w: 40, h: 30},
            {x: 2130, y: 180, w: 60, h: 10},
  {x: 2120, y: 80, w: 10, h: 270},
  {x: 2120, y: 350, w: 160, h: 10},
  {x: 2280, y: 350, w: 120, h: 10},
  {x: 2240, y: 240, w: 10, h: 50},
            {x: 115, y: 1950, w: 20, h: 25},
            {x: 300, y: 2310, w: 20, h: 25},
  {x: 2240, y: 240, w: 50, h: 10},
  {x: 2290, y: 240, w: 10, h: 60},
  {x: 1490, y: 360, w: 110, h: 20},
            {x: 1080, y: 360, w: 350, h: 20},
  {x: 500, y: 1460, w: 10, h: 200},
  {x: 760, y: 1420, w: 10, h: 400},
  {x: 760, y: 1560, w: 280, h: 10},
  {x: 920, y: 1440, w: 380, h: 10},
  {x: 960, y: 1660, w: 220, h: 10},
  {x: 1180, y: 1540, w: 10, h: 300},
  {x: 1360, y: 1600, w: 10, h: 80},
  {x: 1360, y: 1680, w: 160, h: 10},
  {x: 1320, y: 1600, w: 10, h: 120},
  {x: 860, y: 1700, w: 10, h: 420},
  {x: 720, y: 1960, w: 10, h: 400},
  {x: 940, y: 2100, w: 10, h: 240},
  {x: 940, y: 2200, w: 220, h: 10},
  {x: 240, y: 2080, w: 380, h: 10},
  {x: 540, y: 2000, w: 10, h: 80},
  {x: 600, y: 2080, w: 10, h: 180},
  {x: 400, y: 2080, w: 10, h: 80},
  {x: 640, y: 1300, w: 10, h: 280},
  {x: 640, y: 1580, w: 100, h: 10},
  {x: 200, y: 1680, w: 300, h: 10},
  {x: 1040, y: 1780, w: 10, h: 180},
  {x: 1780, y: 1640, w: 340, h: 10},
  {x: 80, y: 460, w: 200, h: 10},
  {x: 380, y: 460, w: 10, h: 360},
  {x: 280, y: 760, w: 100, h: 10},
  {x: 280, y: 760, w: 10, h: 380},
  {x: 240, y: 460, w: 10, h: 500},
  {x: 240, y: 700, w: 100, h: 10},
  {x: 320, y: 560, w: 10, h: 160},
  {x: 520, y: 660, w: 70, h: 10},
  {x: 500, y: 540, w: 10, h: 320},
  {x: 360, y: 980, w: 120, h: 10},
  {x: 420, y: 900, w: 10, h: 140},
  {x: 100, y: 840, w: 120, h: 10},
  {x: 20, y: 980, w: 140, h: 10},
  {x: 100, y: 1000, w: 10, h: 40},
  {x: 1720, y: 680, w: 160, h: 10},
  {x: 1600, y: 600, w: 140, h: 10},
  {x: 1720, y: 780, w: 10, h: 140},
  {x: 1720, y: 860, w: 100, h: 10},
  {x: 1800, y: 860, w: 10, h: 60},
  {x: 1780, y: 400, w: 10, h: 40}
        ],
        red: [
            {x: 20, y: 580, w: 30, h: 120},
  {x: 20, y: 600, w: 120, h: 30},
  {x: 120, y: 580, w: 30, h: 120},
  {x: 20, y: 620, w: 100, h: 30},
  {x: 15, y: 585, w: 110, h: 10}
        ],
        green: [
  {x: 1160, y: 800, w: 160, h: 10},
  {x: 1360, y: 800, w: 180, h: 10},
  {x: 700, y: 1180, w: 420, h: 10},
  {x: 700, y: 440, w: 10, h: 740},
  {x: 700, y: 440, w: 320, h: 10},
  {x: 1020, y: 440, w: 10, h: 620},
  {x: 820, y: 1060, w: 200, h: 10},
  {x: 820, y: 580, w: 10, h: 480},
  {x: 820, y: 580, w: 100, h: 10},
  {x: 920, y: 580, w: 10, h: 340},
  {x: 1220, y: 700, w: 340, h: 10},
  {x: 1160, y: 700, w: 20, h: 10},
  {x: 1160, y: 600, w: 220, h: 10},
  {x: 1420, y: 600, w: 140, h: 10},
  {x: 1160, y: 520, w: 160, h: 10},
  {x: 1360, y: 520, w: 200, h: 10},
  {x: 1160, y: 660, w: 160, h: 10},
  {x: 1440, y: 660, w: 140, h: 10},
  {x: 1420, y: 560, w: 140, h: 10},
  {x: 1180, y: 560, w: 120, h: 10},
  {x: 1160, y: 460, w: 320, h: 10},
            {x: 1480, y: 380, w: 10, h: 90},
  {x: 1320, y: 420, w: 10, h: 20},
  {x: 1400, y: 800, w: 10, h: 40},
  {x: 1400, y: 840, w: 10, h: 20},
  {x: 1160, y: 860, w: 240, h: 10},
  {x: 1440, y: 860, w: 140, h: 10}
        ],
        blue: [
              {x: 0, y: 360, w: 480, h: 10},
            {x: 1180, y: 320, w: 70, h: 10},{x: 1250, y: 320, w: 10, h: 30},
  {x: 700, y: 240, w: 10, h: 100},
  {x: 700, y: 100, w: 10, h: 60},
  {x: 320, y: 120, w: 380, h: 10},
  {x: 380, y: 120, w: 10, h: 160},
  {x: 380, y: 240, w: 80, h: 10},
  {x: 380, y: 200, w: 240, h: 10},
  {x: 540, y: 260, w: 100, h: 10},
  {x: 600, y: 260, w: 10, h: 80},
  {x: 200, y: 100, w: 10, h: 160},
  {x: 200, y: 220, w: 180, h: 10},
  {x: 0, y: 200, w: 120, h: 10},
  {x: 140, y: 60, w: 10, h: 200},
  {x: 140, y: 60, w: 140, h: 10},
  {x: 240, y: 60, w: 10, h: 80},
  {x: 80, y: 100, w: 10, h: 220},
  {x: 260, y: 320, w: 100, h: 10},
  {x: 480, y: 0, w: 10, h: 60},
  {x: 480, y: 60, w: 360, h: 10},
  {x: 860, y: 320, w: 80, h: 10},
  {x: 900, y: 140, w: 10, h: 180},
  {x: 800, y: 80, w: 10, h: 100},
  {x: 1900, y: 360, w: 10, h: 620},
  {x: 2020, y: 160, w: 10, h: 280},
  {x: 1860, y: 240, w: 160, h: 10},
  {x: 2040, y: 560, w: 120, h: 10},
  {x: 2160, y: 500, w: 10, h: 180},
  {x: 2160, y: 620, w: 140, h: 10},
  {x: 2240, y: 480, w: 160, h: 10},
  {x: 1900, y: 820, w: 200, h: 10},
  {x: 1980, y: 680, w: 10, h: 280},
  {x: 2060, y: 940, w: 140, h: 10},
  {x: 1920, y: 1000, w: 320, h: 10},
  {x: 1760, y: 240, w: 10, h: 120},
  {x: 1760, y: 260, w: 200, h: 10},
  {x: 2020, y: 440, w: 140, h: 10},
  {x: 2100, y: 440, w: 10, h: 220},
  {x: 1900, y: 580, w: 80, h: 10},
  {x: 2260, y: 480, w: 10, h: 260},
  {x: 2180, y: 780, w: 10, h: 120},
  {x: 2300, y: 960, w: 100, h: 10},
  {x: 1820, y: 80, w: 300, h: 10},
  {x: 1800, y: 160, w: 10, h: 120},
  {x: 1520, y: 200, w: 280, h: 10},
  {x: 1920, y: 100, w: 10, h: 60},
  {x: 1640, y: 0, w: 10, h: 140},
  {x: 1460, y: 80, w: 200, h: 10},
  {x: 1380, y: 200, w: 160, h: 10},
  {x: 1300, y: 300, w: 250, h: 10},
  {x: 1340, y: 0, w: 10, h: 140},
              {x: 1540, y: 300, w: 10, h: 58},
  {x: 1460, y: 200, w: 10, h: 20},
  {x: 1180, y: 140, w: 10, h: 180},
  {x: 1020, y: 200, w: 80, h: 10},
  {x: 1060, y: 20, w: 10, h: 80}
        ],
        purple: [
            {x: 332, y: 471, w: 20, h: 20},
            {x: 867, y: 1493, w: 20, h: 20}
        ],
        gray: [
            {x: 520, y: 0, w: 20, h: 10}
        ],
        yellow: [
              {x: 1600, y: 1540, w: 800, h: 10},
  {x: 1940, y: 1130, w: 130, h: 10},
  {x: 1740, y: 1180, w: 10, h: 170},
  {x: 1600, y: 1370, w: 10, h: 80},
  {x: 1610, y: 1400, w: 180, h: 10},
  {x: 1830, y: 1310, w: 80, h: 10},
  {x: 1870, y: 1310, w: 10, h: 160},
  {x: 1870, y: 1430, w: 120, h: 10},
  {x: 2000, y: 1400, w: 10, h: 140},
  {x: 1610, y: 1010, w: 160, h: 10},
  {x: 1830, y: 1010, w: 10, h: 140},
  {x: 1750, y: 1010, w: 10, h: 60},
  {x: 1750, y: 1230, w: 140, h: 10},
  {x: 1900, y: 1010, w: 10, h: 160}
        ],
        hotpink: [
            {x: 100, y: 200, w: 20, h: 20}
        ],
        tiled: [
             {x: 1850, y: 2050, w: 10, h: 50},
{x: 1000, y: 350, w: 70, h: 7},{x: 980, y: 310, w: 110, h: 40},{x: 1000, y: 300, w: 70, h: 10},
  {x: 100, y: 1990, w: 60, h: 110},
  {x: 160, y: 1960, w: 60, h: 50},
  {x: 270, y: 2220, w: 220, h: 50},
  {x: 1340, y: 1360, w: 160, h: 50},
  {x: 980, y: 1920, w: 50, h: 80},
  {x: 1000, y: 1960, w: 100, h: 50},
  {x: 1000, y: 1980, w: 80, h: 50},
  {x: 1700, y: 1080, w: 50, h: 40},
             {x: 1320, y: 1740, w: 20, h: 300},
  {x: 1320, y: 2160, w: 20, h: 180},
  {x: 1320, y: 1740, w: 300, h: 20},
  {x: 1320, y: 1830, w: 390, h: 20},
  {x: 1710, y: 1740, w: 20, h: 120},
  {x: 1710, y: 1740, w: 210, h: 20},
  {x: 2010, y: 1740, w: 390, h: 20},
  {x: 1470, y: 2010, w: 20, h: 360},
  {x: 1710, y: 1860, w: 20, h: 180},
  {x: 1590, y: 1950, w: 20, h: 120},
  {x: 1590, y: 2070, w: 120, h: 20},
  {x: 1590, y: 2070, w: 20, h: 180},
  {x: 1830, y: 1830, w: 420, h: 20},
  {x: 2250, y: 1830, w: 20, h: 90},
  {x: 2160, y: 2040, w: 180, h: 20},
  {x: 2160, y: 1920, w: 20, h: 120},
  {x: 1830, y: 1980, w: 240, h: 20},
  {x: 2070, y: 1980, w: 20, h: 150},
  {x: 2070, y: 2100, w: 90, h: 20},
  {x: 2160, y: 2100, w: 20, h: 300},
  {x: 1800, y: 2100, w: 150, h: 20},
  {x: 1920, y: 1980, w: 20, h: 120},
  {x: 1710, y: 1890, w: 270, h: 20},
  {x: 1800, y: 2190, w: 270, h: 20},
  {x: 1800, y: 2250, w: 360, h: 20},
            
  {x: 1680, y: 1140, w: 20, h: 50},
  {x: 1720, y: 1160, w: 50, h: 20},
  {x: 1720, y: 1120, w: 50, h: 40},
  {x: 1740, y: 1100, w: 40, h: 50},
  {x: 1720, y: 1100, w: 40, h: 50},
  {x: 1740, y: 1120, w: 50, h: 40},
  {x: 2280, y: 820, w: 50, h: 40},
  {x: 2300, y: 840, w: 60, h: 50},
  {x: 2300, y: 860, w: 50, h: 20},
  {x: 560, y: 980, w: 30, h: 240},
  {x: 330, y: 1120, w: 190, h: 50},
  {x: 0, y: 1160, w: 380, h: 50},
  {x: 820, y: 1300, w: 150, h: 20},
  {x: 860, y: 1320, w: 80, h: 50},
  {x: 1140, y: 380, w: 30, h: 900},
  {x: 50, y: 1855, w: 160, h: 110},
  {x: 50, y: 1960, w: 55, h: 400},
  {x: 100, y: 2180, w: 120, h: 180},
  {x: 220, y: 2220, w: 60, h: 140},
  {x: 280, y: 2320, w: 40, h: 40},
  {x: 320, y: 2240, w: 60, h: 120},
  {x: 380, y: 2300, w: 20, h: 60},
              {x: 400, y: 2300, w: 40, h: 30},
              {x: 440, y: 2300, w: 60, h: 100},
  {x: 500, y: 2360, w: 40, h: 40},
  {x: 540, y: 2360, w: 560, h: 40},
  {x: 1100, y: 2320, w: 300, h: 80},
  {x: 1600, y: 2340, w: 60, h: 60},
  {x: 2340, y: 1980, w: 60, h: 60},
  {x: 500, y: 1960, w: 60, h: 40},
  {x: 880, y: 2220, w: 20, h: 20}
        ],
        pathway: [
            {x: 280, y: 1220, w: 30, h: 280},
  {x: 280, y: 1360, w: 220, h: 30}
        ]
    };
    
    Object.entries(wallData).forEach(([color, walls]) => {
        walls.forEach(wall => {
            const wallEl = document.createElement('div');
            
            if (color === 'tiled') {
                wallEl.className = 'tiled-wall';
            } else if (color === 'pathway') {
                wallEl.className = 'pathway';
            } else {
                wallEl.className = 'maze-wall';
                wallEl.style.background = color;
            }
            
            wallEl.style.left = wall.x + 'px';
            wallEl.style.top = wall.y + 'px';
            wallEl.style.width = wall.w + 'px';
            wallEl.style.height = wall.h + 'px';
            this.gameWorld.appendChild(wallEl);
        });
    });
    
    this.createBreakableWalls();
}

            createBreakableWalls() {
                const breakableWalls = [
                      {x: 1320, y: 2040, w: 20, h: 120},
  {x: 1620, y: 1740, w: 90, h: 20},
                     {x: 2340, y: 180, w: 60, h: 10},
  {x: 1920, y: 1740, w: 90, h: 20},
  {x: 1470, y: 1830, w: 20, h: 180},
  {x: 2250, y: 1920, w: 150, h: 20},
  {x: 1800, y: 2100, w: 20, h: 90},
  {x: 1920, y: 2100, w: 20, h: 90},
  {x: 1860, y: 2100, w: 20, h: 90},
  {x: 1890, y: 2100, w: 20, h: 90},
  {x: 1830, y: 2100, w: 20, h: 90},
  {x: 1950, y: 2100, w: 20, h: 90},
  {x: 1950, y: 2100, w: 120, h: 20},
                     {x: 540, y: 200, w: 10, h: 100},

                    {x: 520, y: 1120, w: 60, h: 20},
                    {x: 2120, y: 10, w: 10, h: 70}
                ];
                
                breakableWalls.forEach(wall => {
                    const wallEl = document.createElement('div');
                    wallEl.className = 'breakable-wall';
                    wallEl.style.left = wall.x + 'px';
                    wallEl.style.top = wall.y + 'px';
                    wallEl.style.width = wall.w + 'px';
                    wallEl.style.height = wall.h + 'px';
                    wallEl.dataset.breakable = 'true';
                    this.gameWorld.appendChild(wallEl);
                });
            }



            createEmojiWalls() {
    // Simple array of emoji walls - just add coordinates and emoji here
    const emojiWalls = [
        {x: 120, y: 1580, emoji: 'üõèÔ∏è'},
        {x: 2350, y: 1150, emoji: 'üåµ'}
    ];
    
    emojiWalls.forEach(wall => {
        const wallEl = document.createElement('div');
        wallEl.className = 'emoji-wall';
        wallEl.textContent = wall.emoji;
        wallEl.style.position = 'absolute';
        wallEl.style.left = wall.x + 'px';
        wallEl.style.top = wall.y + 'px';
        wallEl.style.width = '20px';
        wallEl.style.height = '20px';
        wallEl.style.fontSize = '18px';
        wallEl.style.display = 'flex';
        wallEl.style.alignItems = 'center';
        wallEl.style.justifyContent = 'center';
        wallEl.style.zIndex = '30';
        wallEl.style.filter = 'grayscale(0.8) brightness(0.7)'; // Match the apocalyptic theme
        this.gameWorld.appendChild(wallEl);
    });
}

            addTreeWalls() {
                const treePositions = [
                    {x: 1060, y: 1140}, {x: 1080, y: 1140}, {x: 1100, y: 1140},
                    {x: 880, y: 1120}, {x: 900, y: 1120}, {x: 920, y: 1120},
                    {x: 320, y: 830}, {x: 320, y: 1000}, {x: 260, y: 910}
                ];
                
                const treeEmojis = ['üå≤', 'üå≥', 'üéÑ'];
                
                treePositions.forEach((pos, index) => {
                    const treeEl = document.createElement('div');
                    treeEl.className = 'tree-wall';
                    treeEl.textContent = treeEmojis[index % treeEmojis.length];
                    treeEl.style.left = pos.x + 'px';
                    treeEl.style.top = pos.y + 'px';
                    treeEl.style.width = '20px';
                    treeEl.style.height = '20px';
                    this.gameWorld.appendChild(treeEl);
                });
            }

            createEnemies() {
                // Main enemies - 30% faster, with HP
                const allEnemies = [
                    {x: 150, y: 200, moveX: 130, moveY: 200, range: 100, axis: 'x', speed: 0.78, emoji: 'üêç', hp: 100},
                    {x: 400, y: 150, moveX: 400, moveY: 130, range: 80, axis: 'y', speed: 0.65, emoji: 'ü¶πüèª‚Äç‚ôÇÔ∏è', hp: 150},
                    {x: 1700, y: 1100, moveX: 1680, moveY: 1100, range: 120, axis: 'x', speed: 0.78, emoji: 'ü¶Ç', hp: 50},
                    {x: 1645, y: 1100, moveX: 1645, moveY: 1080, range: 120, axis: 'y', speed: 0.78, emoji: 'ü¶Ç', hp: 50},
                    {x: 2110, y: 1370, moveX: 2090, moveY: 1370, range: 120, axis: 'x', speed: 0.78, emoji: 'ü¶Ç', hp: 50},
                    {x: 2270, y: 1370, moveX: 2270, moveY: 1350, range: 120, axis: 'y', speed: 0.95, emoji: 'üï∑Ô∏è', hp: 150},
                    {x: 1760, y: 1370, moveX: 1740, moveY: 1370, range: 120, axis: 'x', speed: 0.78, emoji: 'ü¶Ç', hp: 50},

                    {x: 2060, y: 20, moveX: 2040, moveY: 20, range: 120, axis: 'x', speed: 1.78, emoji: 'ü¶à', hp: 350},
                    {x: 2000, y: 60, moveX: 1980, moveY: 60, range: 120, axis: 'x', speed: 1.78, emoji: 'ü¶à', hp: 350},
                    {x: 1980, y: 380, moveX: 1960, moveY: 380, range: 120, axis: 'x', speed: 1.78, emoji: 'ü¶à', hp: 350},
                    {x: 1660, y: 480, moveX: 1640, moveY: 480, range: 120, axis: 'x', speed: 0.52, emoji: 'üê°', hp: 50},
                    {x: 2080, y: 1040, moveX: 2060, moveY: 1040, range: 120, axis: 'x', speed: 0.78, emoji: 'üßõüèª‚Äç‚ôÇÔ∏è', hp: 50},
                    {x: 2260, y: 2080, moveX: 2240, moveY: 2080, range: 120, axis: 'x', speed: 0.78, emoji: 'üßõüèª‚Äç‚ôÇÔ∏è', hp: 50},
                    {x: 1000, y: 1820, moveX: 980, moveY: 1820, range: 120, axis: 'x', speed: 0.78, emoji: 'ü¶Ç', hp: 50},
                    {x: 360, y: 560, moveX: 340, moveY: 560, range: 120, axis: 'x', speed: 1.78, emoji: 'üßå', hp: 250},
                    {x: 200, y: 900, moveX: 180, moveY: 900, range: 220, axis: 'x', speed: 2.98, emoji: 'ü•∑üèª', hp: 250},
                    {x: 1940, y: 1580, moveX: 1920, moveY: 1580, range: 120, axis: 'x', speed: 0.78, emoji: 'ü¶Ç', hp: 50},

                    {x: 1020, y: 1600, moveX: 1020, moveY: 1580, range: 120, axis: 'y', speed: 1.78, emoji: 'üßå', hp: 250},
                    {x: 1440, y: 2220, moveX: 1440, moveY: 2200, range: 120, axis: 'y', speed: 1.78, emoji: 'üßå', hp: 250},
                    {x: 360, y: 2000, moveX: 360, moveY: 1980, range: 120, axis: 'y', speed: 1.78, emoji: 'üßå', hp: 250},
                    {x: 1700, y: 580, moveX: 1700, moveY: 560, range: 320, axis: 'y', speed: 0.98, emoji: 'üë∫', hp: 350},
                    {x: 1040, y: 1380, moveX: 1040, moveY: 1360, range: 120, axis: 'y', speed: 1.78, emoji: 'üßå', hp: 250},
                    {x: 700, y: 1360, moveX: 700, moveY: 1340, range: 120, axis: 'y', speed: 1.78, emoji: 'üßå', hp: 250},
                    {x: 200, y: 660, moveX: 200, moveY: 640, range: 120, axis: 'y', speed: 0.95, emoji: 'üï∑Ô∏è', hp: 150},
                    {x: 1140, y: 180, moveX: 1140, moveY: 160, range: 120, axis: 'y', speed: 0.52, emoji: 'üê°', hp: 50},
                    {x: 2000, y: 1600, moveX: 2000, moveY: 1580, range: 220, axis: 'y', speed: 1.78, emoji: 'üöΩ', hp: 750},
                    {x: 2080, y: 60, moveX: 2080, moveY: 40, range: 120, axis: 'y', speed: 1.78, emoji: 'ü¶à', hp: 350},
                    
                    {x: 640, y: 1780, moveX: 640, moveY: 1760, range: 120, axis: 'y', speed: 1.78, emoji: 'üßå', hp: 250},
                    {x: 920, y: 2270, moveX: 900, moveY: 2270, range: 120, axis: 'x', speed: 1.78, emoji: 'üßå', hp: 250},
                    {x: 200, y: 250, moveX: 180, moveY: 250, range: 100, axis: 'x', speed: 0.52, emoji: 'üê°', hp: 50}
                ];
                
                allEnemies.forEach((enemy, index) => {
                    const enemyEl = document.createElement('div');
                    enemyEl.className = 'enemy';
                    enemyEl.textContent = enemy.emoji;
                    enemyEl.style.left = enemy.x + 'px';
                    enemyEl.style.top = enemy.y + 'px';
                    this.gameWorld.appendChild(enemyEl);
                    
                    this.movingEnemies.push({
                        element: enemyEl,
                        startX: enemy.moveX,
                        startY: enemy.moveY,
                        currentX: enemy.x,
                        currentY: enemy.y,
                        range: enemy.range,
                        axis: enemy.axis,
                        direction: 1,
                        speed: enemy.speed,
                        hp: enemy.hp,
                        maxHp: enemy.hp,
                        alive: true
                    });
                });

                // Add forest bees - killable with 100 HP
this.createForestBees();

// Create appropriate gorilla based on encounter status
this.createGorilla();
            }


            createGorilla() {
    const gorillaX = 1360;
    const gorillaY = 980;
    
    if (this.gorillaEncounterComplete) {
        // Create friendly stationary gorilla
        const friendlyGorillaEl = document.createElement('div');
        friendlyGorillaEl.className = 'friendly gorilla-friend';
        friendlyGorillaEl.textContent = 'ü¶ç';
        friendlyGorillaEl.style.left = gorillaX + 'px';
        friendlyGorillaEl.style.top = gorillaY + 'px';
        friendlyGorillaEl.style.fontSize = '27px';
        friendlyGorillaEl.style.width = '33px';
        friendlyGorillaEl.style.height = '33px';
        friendlyGorillaEl.style.filter = 'none';
        
        // Check if player has defeated pink boss and not yet got hammer power
        if (this.pinkBossDefeated && !this.hasHammerPower) {
            friendlyGorillaEl.dataset.type = 'gorillaFinalDialog';
        } else if (this.gorillaHammerDialogComplete) {
    friendlyGorillaEl.dataset.message = "You are my hero, frog. Go get that Bully!";
        } else {
            friendlyGorillaEl.dataset.message = "ü¶ç Good luck saving my girlfriend! If you succeed, I will give you one more power!";
        }
        
        this.gameWorld.appendChild(friendlyGorillaEl);
        this.gorilla = null; // No aggressive gorilla anymore
        
        if (this.pinkBossDefeated) {
            this.createGorillaGirlfriend();
        }
    } else if (this.collectedBanana) {
        // Create encounter gorilla (stationary, for dialog)
        const encounterGorillaEl = document.createElement('div');
        encounterGorillaEl.className = 'gorilla-encounter';
        encounterGorillaEl.textContent = 'ü¶ç';
        encounterGorillaEl.style.left = gorillaX + 'px';
        encounterGorillaEl.style.top = gorillaY + 'px';
        encounterGorillaEl.style.fontSize = '27px';
        encounterGorillaEl.style.width = '33px';
        encounterGorillaEl.style.height = '33px';
        encounterGorillaEl.style.filter = 'brightness(1.2)';
        encounterGorillaEl.dataset.type = 'gorillaEncounter';
        this.gameWorld.appendChild(encounterGorillaEl);
        this.gorilla = null;
    } else {
        // Create aggressive patrolling gorilla (original behavior)
        const gorillaEl = document.createElement('div');
        gorillaEl.className = 'enemy forest-gorilla';
        gorillaEl.textContent = 'ü¶ç';
        gorillaEl.style.left = gorillaX + 'px';
        gorillaEl.style.top = gorillaY + 'px';
        gorillaEl.style.fontSize = '27px';
        gorillaEl.style.width = '33px';
        gorillaEl.style.height = '33px';
        this.gameWorld.appendChild(gorillaEl);

        this.gorilla = {
            element: gorillaEl,
            type: 'gorilla',
            currentX: gorillaX,
            currentY: gorillaY,
            startX: gorillaX,
            startY: gorillaY,
            patrolRange: 80,
            direction: 1,
            speed: 1.04,
            isChasing: false,
            chaseSpeed: 1.95,
            returning: false,
            alive: true
        };
    }
}

refreshGorilla() {
    // Remove existing gorilla if it exists
    if (this.gorilla && this.gorilla.element) {
        this.gorilla.element.remove();
        this.gorilla = null;
    }
    
    // Remove any existing gorilla elements
    const existingGorillas = this.gameWorld.querySelectorAll('.enemy.forest-gorilla, .gorilla-encounter, .gorilla-friend');
    existingGorillas.forEach(g => g.remove());
    
    // Recreate the gorilla with current state
    this.createGorilla();
}


            createGorillaGirlfriend() {
    const catX = 1460; // 100px to the right of gorilla
    const catY = 980; // Same Y as gorilla
    
    const catEl = document.createElement('div');
    catEl.className = 'friendly cat-girlfriend';
    catEl.style.left = catX + 'px';
    catEl.style.top = catY + 'px';
    catEl.style.width = '25px';
    catEl.style.height = '25px';
    catEl.style.backgroundImage = 'url("https://raw.githubusercontent.com/TheDepression/Photos/main/gfcat-min.png")';
    catEl.style.backgroundSize = 'contain';
    catEl.style.backgroundRepeat = 'no-repeat';
    catEl.style.backgroundPosition = 'center';
    catEl.style.zIndex = '40';
    
    // Set message based on dialog completion
    if (!this.catFirstDialogComplete) {
    catEl.dataset.type = 'catFirstDialog';
    } else {
        catEl.dataset.message = "Cat POWER!! -- You have full health.";
    }
    
    this.gameWorld.appendChild(catEl);
}


            createWeakPoints() {
    const weakPointPositions = [
        {x: 60, y: 628, id: 'weak_point_1', url: 'underground'},
        {x: 880, y: 1345, id: 'weak_point_2', url: 'cavec'},
        {x: 960, y: 2360, id: 'weak_point_3', url: 'caved'},
        {x: 860, y: 620, id: 'weak_point_4', url: 'casino'},
        {x: 1020, y: 340, id: 'weak_point_5', url: 'leaveforest'},
        {x: 2320, y: 820, id: 'weak_point_6', url: 'watercave'}
    ];
    
    weakPointPositions.forEach(pos => {
        // Check if this weak point has been blasted
        const isBlasted = this.weakPointsBlasted.includes(pos.id);
        
        if (isBlasted) {
            // Create black square entrance
            const entrance = document.createElement('div');
            entrance.className = 'weak-point-entrance';
            entrance.style.position = 'absolute';
            entrance.style.left = pos.x + 'px';
            entrance.style.top = pos.y + 'px';
            entrance.style.width = '20px';
            entrance.style.height = '20px';
            entrance.style.background = 'black';
            entrance.style.border = '1px solid #333';
            entrance.style.zIndex = '200';
            entrance.dataset.url = pos.url;
            entrance.dataset.type = 'weakPointEntrance';
            this.gameWorld.appendChild(entrance);
        } else {
            // Create unblasted weak point
            const weakPoint = document.createElement('div');
            weakPoint.className = 'weak-point';
            weakPoint.style.position = 'absolute';
            weakPoint.style.left = pos.x + 'px';
            weakPoint.style.top = pos.y + 'px';
            weakPoint.style.width = '20px';
            weakPoint.style.height = '20px';
            weakPoint.style.backgroundImage = 'url("https://raw.githubusercontent.com/TheDepression/Photos/main/weak.png")';
            weakPoint.style.backgroundSize = 'contain';
            weakPoint.style.backgroundRepeat = 'no-repeat';
            weakPoint.style.backgroundPosition = 'center';
            weakPoint.style.zIndex = '200';
            weakPoint.dataset.id = pos.id;
            weakPoint.dataset.url = pos.url;
            weakPoint.dataset.type = 'weakPoint';
            this.gameWorld.appendChild(weakPoint);
        }
    });
}


            // ADD createForestBees METHOD HERE:
    createForestBees() {
        const forestLeft = 600 + 120;
        const forestRight = 1600 - 120;
        const forestTop = 360 + 120;
        const forestBottom = 1300 - 120;
        
        for (let i = 0; i < 5; i++) {
            const startX = forestLeft + Math.random() * (forestRight - forestLeft);
            const startY = forestTop + Math.random() * (forestBottom - forestTop);
            
            const beeEl = document.createElement('div');
            beeEl.className = 'enemy forest-bee';
            beeEl.textContent = 'üêù';
            beeEl.style.left = startX + 'px';
            beeEl.style.top = startY + 'px';
            beeEl.style.zIndex = '80';
            this.gameWorld.appendChild(beeEl);
            
            this.movingEnemies.push({
                element: beeEl,
                type: 'bee',
                currentX: startX,
                currentY: startY,
                targetX: startX,
                targetY: startY,
                speed: 1.56, // 1.2 * 1.3 (30% faster)
                changeDirectionTimer: 0,
                forestBounds: {
                    left: forestLeft,
                    right: forestRight,
                    top: forestTop,
                    bottom: forestBottom
                },
                hp: 100, // 2-hit kill
                maxHp: 100,
                alive: true
            });
        }
    }


            createFriendlies() {
                // Post-apocalyptic NPC messages - same positions, new dialogue
                const friendlies = [
                    {x: 1200, y: 2000, message: "I am a broken man.", customEmoji: "üë¥üèª"},
                    {x: 1400, y: 1330, message: "Your boat is broken?... I will repair if for 700 yen.", customEmoji: "üë©‚Äç‚öïÔ∏è"},
                    {x: 60, y: 60, message: "There used to be an island here. The landscape has changed quite a bit. Luckily for me, I can float.", customEmoji: "üßô‚Äç‚ôÄÔ∏è"},
                    {x: 140, y: 1680, message: "Thank you for reuniting me with my baby before the world ended...", customEmoji: "üë©üèª"},
                    {x: 160, y: 1680, message: "Thank you for rescuing me...Waah waah", customEmoji: "üë∂üèª"},
                     {x: 500, y: 1560, message: "Watch out for my father.. The Bully made him. He made me too but I am just a baby. Someday I can attack you, but for now, I am friendly.", customEmoji: "üí©"},
                     {x: 160, y: 1580, message: "You are finally awake! The pyramid collapsed and the Bully escaped to the castle. He unleashed a giant brown monster that is destroying our town. Everything is destroyed...", customEmoji: "üëÆüèª‚Äç‚ôÇÔ∏è"},
                     {x: 140, y: 1500, message: "I cannot believe we got out of that pyramid. You were unconscious for a few days. Your boat seems to have broken and your hammer was lost in the rubble... But at least we survived", customEmoji: "üôçüèª‚Äç‚ôÇÔ∏è"},
                    {x: 200, y: 1600, message: "You should visit the boat seller in the forest. Her prices have increased after the disaster, but youre gonna need a boat to get anywhere useful in this broken world.", customEmoji: "üê∏"},
                    {x: 450, y: 960, message: "My sister has the power to heal health. The Bully kidnapped her to use her DNA for his machine. That is why he keeps surviving. Oh, I miss my sister.", customEmoji: "üò∫"},
                    {x: 640, y: 960, message: "You should not be here!", customEmoji: "ü™ß"},
                    {x: 720, y: 420, message: "Seriously, it is too dangerous.", customEmoji: "ü™ß"},
                    {x: 980, y: 400, message: "You can escape the forest here. GET OUT NOW!", customEmoji: "ü™ß"},
                    {x: 1080, y: 1120, message: "The bees will kill you. GO BACK NOW!", customEmoji: "ü™ß"},
                    {x: 780, y: 560, message: "WHY ARE YOU NOT LISTENING!?!", customEmoji: "ü™ß"},
                    {x: 880, y: 720, message: "Private... Do NOT enter!", customEmoji: "ü™ß"},
                    {x: 1940, y: 2020, message: "", customEmoji: "ü§µüèª‚Äç‚ôÇÔ∏è", specialType: "battleNPC"},
                    {x: 2200, y: 2280, message: "The bully cannot keep me down! I have rebuilt my shop even better. Take a look inside.", customEmoji: "ü•∏"}
                ];
                
                friendlies.forEach((friendly, index) => {
                    const friendlyEl = document.createElement('div');
                    friendlyEl.className = 'friendly';
                    friendlyEl.textContent = friendly.customEmoji;
                    friendlyEl.style.left = friendly.x + 'px';
                    friendlyEl.style.top = friendly.y + 'px';
                    friendlyEl.dataset.message = friendly.message;
                    this.gameWorld.appendChild(friendlyEl);
                });
            }

            // ADD THIS NEW METHOD:
createCollectibles() {
    // Create red hearts for testing (around x:40 y:1400 area)
    const redHeartPositions = [
        {x: 40, y: 1400, id: 'red_heart_1'},
        {x: 60, y: 1420, id: 'red_heart_2'},
        {x: 80, y: 1400, id: 'red_heart_3'},
        {x: 100, y: 1420, id: 'red_heart_4'},
        {x: 40, y: 1440, id: 'red_heart_5'},
        {x: 60, y: 1460, id: 'red_heart_6'},
        {x: 80, y: 1440, id: 'red_heart_7'},
        {x: 100, y: 1460, id: 'red_heart_8'},
        {x: 1940, y: 860, id: 'red_heart_9'},
    {x: 1080, y: 1200, id: 'red_heart_10'},
    {x: 1480, y: 2300, id: 'red_heart_11'},
        {x: 2200, y: 1820, id: 'red_heart_12'}
    ];

    redHeartPositions.forEach(pos => {
        // Only create if not already collected
        if (!this.collectedRedHearts.includes(pos.id)) {
            const heartEl = document.createElement('div');
            heartEl.className = 'heart-pickup';
            heartEl.textContent = '‚ù§Ô∏è';
            heartEl.style.left = pos.x + 'px';
            heartEl.style.top = pos.y + 'px';
            heartEl.dataset.id = pos.id;
            heartEl.dataset.type = 'redHeart';
            this.gameWorld.appendChild(heartEl);
        }
    });
}


            createMoneyCollectibles() {
    // Create money pickups in the same area as red hearts
    const moneyPositions = [
        {x: 2340, y: 1480, id: 'money_1'},
        {x: 2360, y: 1480, id: 'money_2'},
        {x: 1590, y: 760, id: 'money_3'},
        {x: 760, y: 320, id: 'money_4'},
        {x: 1230, y: 410, id: 'money_5'},
        {x: 1180, y: 840, id: 'money_6'},
        {x: 2120, y: 2360, id: 'money_7'},
        {x: 260, y: 2180, id: 'money_8'},
                {x: 2160, y: 200, id: 'money_9'},
                {x: 20, y: 140, id: 'money_10'}
    ];

    moneyPositions.forEach(pos => {
        // Only create if not already collected
        if (!this.collectedMoney.includes(pos.id)) {
            const moneyEl = document.createElement('div');
            moneyEl.className = 'money-pickup';
            moneyEl.textContent = 'üí∞';
            moneyEl.style.left = pos.x + 'px';
            moneyEl.style.top = pos.y + 'px';
            moneyEl.dataset.id = pos.id;
            moneyEl.dataset.type = 'permanentMoney';
            moneyEl.dataset.value = '100'; // 100 yen each
            this.gameWorld.appendChild(moneyEl);
        }
    });
}

         

            createPurpleHearts() {
    const purpleHeartPositions = [
        {x: 420, y: 2330, id: 'purple_heart_1'},
        {x: 1220, y: 355, id: 'purple_heart_2'},
        {x: 2290, y: 1220, id: 'purple_heart_3'} // Hidden under fake quicksand
        {x: 2380, y: 2380, id: 'purple_heart_4'},    // purple
    {x: 2340, y: 2380, id: 'purple_heart_5'},    //purple
    {x: 2300, y: 2380, id: 'purple_heart_6'},     //purple
    {x: 2260, y: 2380, id: 'purple_heart_7'},     //purple
    ];

    purpleHeartPositions.forEach(pos => {
        // Only create if not already collected
        if (!this.collectedPurpleHearts.includes(pos.id)) {
            const purpleHeartEl = document.createElement('div');
            purpleHeartEl.className = 'purple-heart-pickup';
            purpleHeartEl.textContent = 'üíú';
            purpleHeartEl.style.left = pos.x + 'px';
            purpleHeartEl.style.top = pos.y + 'px';
            purpleHeartEl.dataset.id = pos.id;
            purpleHeartEl.dataset.type = 'purpleHeart';
            
            // Special handling for the hidden heart (lower z-index so fake quicksand covers it)
            if (pos.id === 'purple_heart_3') {
                purpleHeartEl.style.zIndex = '70'; // Lower than fake quicksand (80)
            }
            
            this.gameWorld.appendChild(purpleHeartEl);
        }
    });
}



            createBanana() {
    // Only create if not collected AND encounter not complete
    if (!this.collectedBanana && !this.gorillaEncounterComplete) {
        const bananaEl = document.createElement('div');
        bananaEl.className = 'banana-pickup';
        bananaEl.style.position = 'absolute';
        bananaEl.style.left = '290px';
        bananaEl.style.top = '1100px';
        bananaEl.style.width = '25px';
        bananaEl.style.height = '35px';
        bananaEl.style.backgroundImage = 'url("https://raw.githubusercontent.com/TheDepression/Photos/main/bananaprize-min.png")';
        bananaEl.style.backgroundSize = 'contain';
        bananaEl.style.backgroundRepeat = 'no-repeat';
        bananaEl.style.backgroundPosition = 'center';
        bananaEl.style.zIndex = '60';
        bananaEl.style.animation = 'glow 2s infinite';
        bananaEl.dataset.type = 'banana';
        this.gameWorld.appendChild(bananaEl);
    }
}


            createFakeTiledWalls() {
    // Fake tiled walls that look real but you can walk through
    const fakeTiledWalls = [
        {x: 20, y: 1860, w: 40, h: 540},
        {x: 20, y: 2360, w: 280, h: 40}
    ];
    
    fakeTiledWalls.forEach(wall => {
        const wallEl = document.createElement('div');
        wallEl.className = 'fake-tiled-wall';
        wallEl.style.left = wall.x + 'px';
        wallEl.style.top = wall.y + 'px';
        wallEl.style.width = wall.w + 'px';
        wallEl.style.height = wall.h + 'px';
        wallEl.dataset.type = 'fake-wall'; // For identification if needed
        this.gameWorld.appendChild(wallEl);
    });
}

            createExit() {
                const exitEl = document.createElement('div');
                exitEl.className = 'exit';
                exitEl.textContent = 'üö™';
                exitEl.style.left = '2250px';
                exitEl.style.top = '260px';
                this.gameWorld.appendChild(exitEl);
            }

            createDestroyedPyramid() {
                const pyramidHitbox = document.createElement('div');
                pyramidHitbox.style.position = 'absolute';
                pyramidHitbox.style.left = '2200px';
                pyramidHitbox.style.top = '1300px';
                pyramidHitbox.style.width = '60px';
                pyramidHitbox.style.height = '60px';
                pyramidHitbox.style.background = 'rgba(100,100,100,0.3)';
                pyramidHitbox.style.border = '2px dashed #666';
                pyramidHitbox.style.borderRadius = '4px';
                pyramidHitbox.style.zIndex = '35';
                pyramidHitbox.dataset.type = 'destroyedPyramid';
                this.gameWorld.appendChild(pyramidHitbox);
            }

            startGameLoop() {
                const gameLoop = () => {
                    if (this.gameStarted) {
                        this.updatePlayer();
                        this.updateQuicksand(); // Add this line
                        this.updateMovingEnemies();
                        this.updateForegroundEnemy();
                        this.checkCollisions();
                    }
                    requestAnimationFrame(gameLoop);
                };
                gameLoop();
            }

            updatePlayer() {
    if (this.isPaused) return;
    if (Math.abs(this.playerVelocityX) > 0.1 || Math.abs(this.playerVelocityY) > 0.1) {
        const newX = this.playerX + this.playerVelocityX;
        const newY = this.playerY + this.playerVelocityY;
        
        if (this.canMoveTo(newX, newY)) {
            this.playerX = newX;
            this.playerY = newY;
            
            const visualOffset = (32 - 24) / 2;
            this.player.style.left = (this.playerX - visualOffset) + 'px';
            this.player.style.top = (this.playerY - visualOffset) + 'px';
            
            const gameAreaWidth = this.gameArea.offsetWidth;
            const gameAreaHeight = this.gameArea.offsetHeight;
            const scrollX = this.playerX - gameAreaWidth / 2 + 12;
            const scrollY = this.playerY - gameAreaHeight / 2 + 12;
            this.gameArea.scrollTo({
                left: scrollX,
                top: scrollY,
                behavior: 'auto'
            });


            // Add this after the scrollTo code:
if (this.isInForest) {
    const mask = document.getElementById('forestVisionMask');
    const gameAreaRect = this.gameArea.getBoundingClientRect();
    const playerScreenX = gameAreaRect.left + (this.gameArea.offsetWidth / 2);
    const playerScreenY = gameAreaRect.top + (this.gameArea.offsetHeight / 2);
    mask.style.background = `radial-gradient(circle 111px at ${playerScreenX}px ${playerScreenY}px, transparent 111px, black 111px)`;
}
        }
        
        // ADD THE MISSING FRICTION CODE:
        let friction = this.isOnDesert ? 0.7 : 0.9;
        if (this.sinkingInQuicksand) {
            friction *= 0.1; // Very hard to move, but not impossible
        }
        this.playerVelocityX *= friction;
        this.playerVelocityY *= friction;
    }
} // <- CLOSE updatePlayer() method here

// NOW ADD updateQuicksand() as a separate method:
updateQuicksand() {
    if (!this.sinkingInQuicksand || !this.quicksandCenter) return;
    
    // Calculate pull towards center
    const playerCenterX = this.playerX + 12;
    const playerCenterY = this.playerY + 12;
    const deltaX = this.quicksandCenter.x - playerCenterX;
    const deltaY = this.quicksandCenter.y - playerCenterY;
    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    
    if (distance > 1) { // Prevent jittering at center
        // Pull strength increases as you get closer to center
        const pullStrength = Math.max(0.3, (30 - distance) / 30 * 1.5);
        const pullX = (deltaX / distance) * pullStrength;
        const pullY = (deltaY / distance) * pullStrength;
        
        // Apply pull directly to position (bypassing wall collision)
        const newX = this.playerX + pullX;
        const newY = this.playerY + pullY;
        
        this.playerX = newX;
        this.playerY = newY;
        
        // Update visual position
        const visualOffset = (32 - 24) / 2;
        this.player.style.left = (this.playerX - visualOffset) + 'px';
        this.player.style.top = (this.playerY - visualOffset) + 'px';
        
        // Update camera
        const gameAreaWidth = this.gameArea.offsetWidth;
        const gameAreaHeight = this.gameArea.offsetHeight;
        const scrollX = this.playerX - gameAreaWidth / 2 + 12;
        const scrollY = this.playerY - gameAreaHeight / 2 + 12;
        this.gameArea.scrollTo({
            left: scrollX,
            top: scrollY,
            behavior: 'auto'
        });
    }
}

            updateMovingEnemies() {
    if (this.isPaused) return;
    
    this.movingEnemies.forEach(enemy => {
        if (!enemy.alive) return;
        
        if (enemy.type === 'bee') {
            // Update bee movement
            enemy.changeDirectionTimer--;
            
            if (enemy.changeDirectionTimer <= 0) {
                enemy.targetX = enemy.forestBounds.left + Math.random() * (enemy.forestBounds.right - enemy.forestBounds.left);
                enemy.targetY = enemy.forestBounds.top + Math.random() * (enemy.forestBounds.bottom - enemy.forestBounds.top);
                enemy.changeDirectionTimer = 60 + Math.random() * 120;
            }
            
            const deltaX = enemy.targetX - enemy.currentX;
            const deltaY = enemy.targetY - enemy.currentY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            if (distance > 5) {
                enemy.currentX += (deltaX / distance) * enemy.speed;
                enemy.currentY += (deltaY / distance) * enemy.speed;
            }
            
            enemy.element.style.left = enemy.currentX + 'px';
            enemy.element.style.top = enemy.currentY + 'px';
        } else {
            // Original enemy movement for non-bee enemies
            if (enemy.axis === 'x') {
                enemy.currentX += enemy.direction * enemy.speed;
                if (enemy.currentX <= enemy.startX || enemy.currentX >= enemy.startX + enemy.range) {
                    enemy.direction *= -1;
                }
                enemy.element.style.left = enemy.currentX + 'px';
            } else {
                enemy.currentY += enemy.direction * enemy.speed;
                if (enemy.currentY <= enemy.startY || enemy.currentY >= enemy.startY + enemy.range) {
                    enemy.direction *= -1;
                }
                enemy.element.style.top = enemy.currentY + 'px';
            }
        }
    });
    
    this.updateGorilla();
}

            updateGorilla() {
    if (!this.gorilla) return;
    
    const playerDistance = Math.sqrt(
        Math.pow(this.playerX - this.gorilla.currentX, 2) + 
        Math.pow(this.playerY - this.gorilla.currentY, 2)
    );
    
    // Check if player is in forest and close enough to start chasing
    if (this.isInForest && playerDistance <= 60 && !this.gorilla.isChasing) {
        this.gorilla.isChasing = true;
        this.showMessage('ü¶ç ROAR! Gorilla is angry!');
    }
    
    // Stop chasing if player escapes forest or gets far enough away
    if (this.gorilla.isChasing && (!this.isInForest || playerDistance >= 250)) {
        this.gorilla.isChasing = false;
        this.gorilla.returning = true;
        this.showMessage('ü¶ç Gorilla calmed down...');
    }
    
    if (this.gorilla.isChasing) {
        // Chase the player
        const deltaX = this.playerX - this.gorilla.currentX;
        const deltaY = this.playerY - this.gorilla.currentY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        if (distance > 5) {
            const moveX = (deltaX / distance) * this.gorilla.chaseSpeed;
            const moveY = (deltaY / distance) * this.gorilla.chaseSpeed;
            
            // Check if gorilla can move to new position
            if (this.canGorillaMoveTo(this.gorilla.currentX + moveX, this.gorilla.currentY + moveY)) {
                this.gorilla.currentX += moveX;
                this.gorilla.currentY += moveY;
            }
        }
    } else if (this.gorilla.returning) {
        // Return to starting position
        const deltaX = this.gorilla.startX - this.gorilla.currentX;
        const deltaY = this.gorilla.startY - this.gorilla.currentY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        if (distance > 5) {
            const moveX = (deltaX / distance) * this.gorilla.speed * 1.5;
            const moveY = (deltaY / distance) * this.gorilla.speed * 1.5;
            
            if (this.canGorillaMoveTo(this.gorilla.currentX + moveX, this.gorilla.currentY + moveY)) {
                this.gorilla.currentX += moveX;
                this.gorilla.currentY += moveY;
            }
        } else {
            this.gorilla.returning = false;
            this.gorilla.currentX = this.gorilla.startX;
            this.gorilla.currentY = this.gorilla.startY;
            this.gorilla.direction = 1;
        }
    } else {
        // Patrol behavior
        this.gorilla.currentX += this.gorilla.direction * this.gorilla.speed;
        
        if (this.gorilla.currentX <= this.gorilla.startX || 
            this.gorilla.currentX >= this.gorilla.startX + this.gorilla.patrolRange) {
            this.gorilla.direction *= -1;
        }
    }
    
    this.gorilla.element.style.left = this.gorilla.currentX + 'px';
    this.gorilla.element.style.top = this.gorilla.currentY + 'px';
}

            updateForegroundEnemy() {
                if (this.isPaused) return;
                if (!this.gameStarted) return;
                const now = Date.now();
                
                if (!this.foregroundEnemy && now - this.lastForegroundSpawn > 20000 && !this.pinkBossDefeated) {
                    const desertLeft = 1600;
                    const desertTop = 1000;
                    const startX = desertLeft + 50;
                    const startY = desertTop + 50;
                    
                    const enemyEl = document.createElement('div');
                    enemyEl.className = 'foreground-enemy';
                enemyEl.style.backgroundImage = 'url("https://raw.githubusercontent.com/TheDepression/Photos/main/pmonster-min.png")';
                    enemyEl.style.left = startX + 'px';
                    enemyEl.style.top = startY + 'px';
                    this.gameWorld.appendChild(enemyEl);
                    
                    this.foregroundEnemy = {
                        element: enemyEl,
                        x: startX,
                        y: startY,
                        speed: 2.07, // 1.8 * 1.15 (15% faster)
                        state: 'moving',
                        direction: Math.random() < 0.5 ? 'left' : 'right',
                        rideDistance: 0,
                        targetRideDistance: 0,
                        rideDirection: null
                    };
                    this.lastForegroundSpawn = now;
                }
                
                if (this.foregroundEnemy) {
                    // Same movement logic as original tornado, just faster
                    if (this.foregroundEnemy.state === 'moving') {
                        if (this.foregroundEnemy.direction === 'left') {
                            this.foregroundEnemy.x -= this.foregroundEnemy.speed;
                            if (this.foregroundEnemy.x <= 20) {
                                this.foregroundEnemy.state = 'riding';
                                this.foregroundEnemy.rideDirection = Math.random() < 0.5 ? 'up' : 'down';
                                const distances = [300, 800, 1500];
                                this.foregroundEnemy.targetRideDistance = distances[Math.floor(Math.random() * distances.length)];
                                this.foregroundEnemy.rideDistance = 0;
                                this.foregroundEnemy.x = 20;
                            }
                        } else if (this.foregroundEnemy.direction === 'right') {
                            this.foregroundEnemy.x += this.foregroundEnemy.speed;
                            if (this.foregroundEnemy.x >= 2360) {
                                this.foregroundEnemy.state = 'riding';
                                this.foregroundEnemy.rideDirection = Math.random() < 0.5 ? 'up' : 'down';
                                const distances = [300, 800, 1500];
                                this.foregroundEnemy.targetRideDistance = distances[Math.floor(Math.random() * distances.length)];
                                this.foregroundEnemy.rideDistance = 0;
                                this.foregroundEnemy.x = 2360;
                            }
                        }
                    } else if (this.foregroundEnemy.state === 'riding') {
                        if (this.foregroundEnemy.rideDirection === 'up') {
                            this.foregroundEnemy.y -= this.foregroundEnemy.speed;
                            this.foregroundEnemy.rideDistance += this.foregroundEnemy.speed;
                            
                            if (this.foregroundEnemy.y <= 20) {
                                this.foregroundEnemy.y = 20;
                                this.foregroundEnemy.rideDirection = 'down';
                            }
                            
                            if (this.foregroundEnemy.rideDistance >= this.foregroundEnemy.targetRideDistance) {
                                this.foregroundEnemy.state = 'moving';
                                this.foregroundEnemy.direction = this.foregroundEnemy.x <= 20 ? 'right' : 'left';
                            }
                        } else if (this.foregroundEnemy.rideDirection === 'down') {
                            this.foregroundEnemy.y += this.foregroundEnemy.speed;
                            this.foregroundEnemy.rideDistance += this.foregroundEnemy.speed;
                            
                            if (this.foregroundEnemy.y >= 2360) {
                                this.foregroundEnemy.y = 2360;
                                this.foregroundEnemy.rideDirection = 'up';
                            }
                            
                            if (this.foregroundEnemy.rideDistance >= this.foregroundEnemy.targetRideDistance) {
                                this.foregroundEnemy.state = 'moving';
                                this.foregroundEnemy.direction = this.foregroundEnemy.x <= 20 ? 'right' : 'left';
                            }
                        }
                    }
                    
                    this.foregroundEnemy.element.style.left = this.foregroundEnemy.x + 'px';
                    this.foregroundEnemy.element.style.top = this.foregroundEnemy.y + 'px';
                    
                    if (this.foregroundEnemy.x < -78 || this.foregroundEnemy.x > 2478 || 
                        this.foregroundEnemy.y < -78 || this.foregroundEnemy.y > 2478) {
                        this.foregroundEnemy.element.remove();
                        this.foregroundEnemy = null;
                    }
                }
            }

            canMoveTo(x, y) {
                const playerSize = 24;
                const padding = 2;
                
                const points = [
    {x: x + padding, y: y + padding},
    {x: x + playerSize - padding, y: y + padding},
    {x: x + padding, y: y + playerSize - padding},
    {x: x + playerSize - padding, y: y + playerSize - padding},
    {x: x + playerSize/2, y: y + padding},
    {x: x + playerSize/2, y: y + playerSize - padding},
    {x: x + padding, y: y + playerSize/2},
    {x: x + playerSize - padding, y: y + playerSize/2}
];
                
                const walls = this.gameWorld.querySelectorAll('.maze-wall, .tree-wall, .breakable-wall, .tiled-wall, .emoji-wall');
                
                for (let wall of walls) {
                    const wallRect = {
                        left: parseInt(wall.style.left),
                        top: parseInt(wall.style.top),
                        right: parseInt(wall.style.left) + (parseInt(wall.style.width) || 20),
                        bottom: parseInt(wall.style.top) + (parseInt(wall.style.height) || 20)
                    };
                    
                    for (let point of points) {
                        if (point.x >= wallRect.left && point.x <= wallRect.right &&
                            point.y >= wallRect.top && point.y <= wallRect.bottom) {
                            
                            if (wall.dataset.breakable === 'true' && this.hasHammer) {
                                this.breakWall(wall);
                                return true;
                            }
                            return false;
                        }
                    }
                }
                
                // Check water zones - need boat to enter
                const waterZones = this.gameWorld.querySelectorAll('[data-zone-type="water"]');
                let isEnteringWater = false;
                
                for (let zone of waterZones) {
                    const zoneRect = {
                        left: parseInt(zone.style.left),
                        top: parseInt(zone.style.top),
                        right: parseInt(zone.style.left) + parseInt(zone.style.width),
                        bottom: parseInt(zone.style.top) + parseInt(zone.style.height)
                    };
                    
                    if (x + playerSize/2 >= zoneRect.left && x + playerSize/2 <= zoneRect.right &&
                        y + playerSize/2 >= zoneRect.top && y + playerSize/2 <= zoneRect.bottom) {
                        isEnteringWater = true;
                        break;
                    }
                }
                
                if (isEnteringWater && (!this.hasBoat || this.boatIsBroken)) {
    if (this.boatIsBroken) {
        this.showMessage('‚õµüíî Your boat is broken. You can\'t ride it!');
    } else {
        this.showMessage('üåä You need a boat to cross water!');
    }
    return false;
}
                
                return true;
            }

            breakWall(wall) {
                this.showMessage('üî® *SMASH* Wall broken!');
                wall.remove();
            }

            checkCollisions() {
                if (this.isPaused) return;
                if (this.isInvulnerable) return;
                
                const playerRect = {
                    left: this.playerX,
                    top: this.playerY,
                    right: this.playerX + 24,
                    bottom: this.playerY + 24
                };
                
                // Check zone-based effects
                this.checkZoneEffects();
                
                // Check enemy collisions
                this.movingEnemies.forEach(enemy => {
                    if (!enemy.alive) return;
                    
                    const enemyRect = {
                        left: enemy.currentX,
                        top: enemy.currentY,
                        right: enemy.currentX + 22,
                        bottom: enemy.currentY + 22
                    };
                    
                    if (this.rectsOverlap(playerRect, enemyRect)) {
                        this.takeDamage();
                    }
                });

                // Check gorilla collision
                if (this.gorilla && this.gorilla.alive) {
                    const gorillaRect = {
                        left: this.gorilla.currentX,
                        top: this.gorilla.currentY,
                        right: this.gorilla.currentX + 33,
                        bottom: this.gorilla.currentY + 33
                    };
                    
                    if (this.rectsOverlap(playerRect, gorillaRect)) {
                        this.takeDamage();
                    }
                }
                
                // Check foreground enemy collision
                if (this.foregroundEnemy) {
                    const fgEnemyRect = {
                        left: this.foregroundEnemy.x,
                        top: this.foregroundEnemy.y,
                        right: this.foregroundEnemy.x + 78,
                        bottom: this.foregroundEnemy.y + 78
                    };
                    
                    if (this.rectsOverlap(playerRect, fgEnemyRect)) {
                        this.gameOver();
                    }
                }
                
                // Check friendly NPCs (replace the existing friendly NPC section)
const friendlies = this.gameWorld.querySelectorAll('.friendly');
let playerOnNPC = false;
let currentNPCMessage = null;

friendlies.forEach(friendly => {
    const friendlyX = parseInt(friendly.style.left);
    const friendlyY = parseInt(friendly.style.top);
    const friendlyRect = {
        left: friendlyX,
        top: friendlyY,
        right: friendlyX + 22,
        bottom: friendlyY + 22
    };
    
    if (this.rectsOverlap(playerRect, friendlyRect)) {
        playerOnNPC = true;
        currentNPCMessage = friendly.dataset.message;
        
        // Check for special dialog types
        if (friendly.dataset.type === 'gorillaFinalDialog') {
            this.startGorillaFinalDialog();
        } else if (friendly.dataset.type === 'catFirstDialog') {
            this.startCatFirstDialog();
        } else if (friendlyX === 1400 && friendlyY === 1330) {
            // Boat repair NPC
            this.checkBoatRepairTransaction(friendly);
        } else if (friendly.classList.contains('cat-girlfriend')) {
            // Cat healing power
            this.handleCatHealing();
        } else {
            // Regular NPC message
            const messageEl = document.getElementById('message');
            if (messageEl.style.display === 'none' || messageEl.textContent !== currentNPCMessage) {
                this.showNPCMessage(currentNPCMessage);
            }
        }
    }
});

// Hide message if not standing on any NPC
if (!playerOnNPC) {
    this.clearNPCMessage();
}



                // Check RPG House collision
const rpgHouse = this.gameWorld.querySelector('[data-type="rpgHouse"]');
if (rpgHouse) {
    const houseX = parseInt(rpgHouse.style.left);
    const houseY = parseInt(rpgHouse.style.top);
    const houseRect = {
        left: houseX + 25, // Slightly smaller hitbox
        top: houseY + 25,
        right: houseX + 55,
        bottom: houseY + 55
    };
    
    if (this.rectsOverlap(playerRect, houseRect)) {
        this.transferToShop();
    }
}

// Check battle NPC with cooldown
const battleNPC = Array.from(friendlies).find(npc => 
    npc.dataset.specialType === 'battleNPC' || 
    (parseInt(npc.style.left) === 1940 && parseInt(npc.style.top) === 2020)
);

if (battleNPC) {
    const npcX = parseInt(battleNPC.style.left);
    const npcY = parseInt(battleNPC.style.top);
    const npcRect = {
        left: npcX,
        top: npcY,
        right: npcX + 22,
        bottom: npcY + 22
    };
    
    if (this.rectsOverlap(playerRect, npcRect)) {
        this.handleBattleNPC();
    }
}

// Check weak point entrances
const entrances = this.gameWorld.querySelectorAll('.weak-point-entrance');
entrances.forEach(entrance => {
    const entranceX = parseInt(entrance.style.left);
    const entranceY = parseInt(entrance.style.top);
    const entranceRect = {
        left: entranceX - 5,
        top: entranceY - 5,
        right: entranceX + 25,
        bottom: entranceY + 25
    };
    
    if (this.rectsOverlap(playerRect, entranceRect)) {
        const url = entrance.dataset.url;
        this.transferToWeakPoint(url);
    }
});

                // Check heart and money drops
                const hearts = this.gameWorld.querySelectorAll('.heart-pickup[data-type="drop"]');
                hearts.forEach(heart => {
                    const heartX = parseInt(heart.style.left);
                    const heartY = parseInt(heart.style.top);
                    const heartRect = {
                        left: heartX, top: heartY,
                        right: heartX + 22, bottom: heartY + 22
                    };
                    
                    if (this.rectsOverlap(playerRect, heartRect)) {
                        if (this.hearts < this.maxHearts) {
                            this.hearts++;
                            this.showMessage('‚ù§Ô∏è Health restored!');
                            this.updateUI();
                            heart.remove();
                        }
                    }
                });


                // Check purple heart pickup
const purpleHearts = this.gameWorld.querySelectorAll('.purple-heart-pickup');
purpleHearts.forEach(purpleHeart => {
    // Skip if already being collected
    if (purpleHeart.dataset.collecting === 'true') return;
    
    const heartX = parseInt(purpleHeart.style.left);
    const heartY = parseInt(purpleHeart.style.top);
    const heartRect = {
        left: heartX, top: heartY,
        right: heartX + 22, bottom: heartY + 22
    };
    
    if (this.rectsOverlap(playerRect, heartRect)) {

        // CHECK IF ALREADY COLLECTED FIRST debido
    if (this.collectedPurpleHearts.includes(purpleHeart.dataset.id)) {
        purpleHeart.remove(); // Clean up if somehow still visible
        return;
    }
        // Mark as being collected to prevent double-collection
        purpleHeart.dataset.collecting = 'true';
        
        // Increase max hearts permanently
        this.maxHearts++;
        this.hearts = this.maxHearts; // Fill to new max
        this.collectedPurpleHearts.push(purpleHeart.dataset.id); // Track collection
        this.showMessage(`üíú Max health increased to ${this.maxHearts}! ‚ö°`);
        this.updateUI();
        this.saveGameState(); // Auto-save the permanent upgrade
        purpleHeart.remove();
    }
});


                // Check red hearts (permanent map hearts)
const redHearts = this.gameWorld.querySelectorAll('.heart-pickup[data-type="redHeart"]');
redHearts.forEach(heart => {
    const heartX = parseInt(heart.style.left);
    const heartY = parseInt(heart.style.top);
    const heartRect = {
        left: heartX, top: heartY,
        right: heartX + 22, bottom: heartY + 22
    };
    
    if (this.rectsOverlap(playerRect, heartRect)) {
        if (this.hearts < this.maxHearts) {
            this.hearts++;
            this.collectedRedHearts.push(heart.dataset.id); // Track collection
            this.showMessage('‚ù§Ô∏è Health restored!');
            this.updateUI();
            this.saveGameState(); // Save the collection
            heart.remove();
        }
    }
});


                // Check gorilla encounter
const gorillaEncounter = this.gameWorld.querySelector('.gorilla-encounter');
if (gorillaEncounter && this.collectedBanana && !this.gorillaEncounterComplete) {
    const gorillaX = parseInt(gorillaEncounter.style.left);
    const gorillaY = parseInt(gorillaEncounter.style.top);
    const gorillaRect = {
        left: gorillaX, top: gorillaY,
        right: gorillaX + 33, bottom: gorillaY + 33
    };
    
    if (this.rectsOverlap(playerRect, gorillaRect)) {
        this.startGorillaDialog();
    }
}


                // Check banana pickup
const banana = this.gameWorld.querySelector('.banana-pickup');
if (banana) {
    const bananaX = parseInt(banana.style.left);
    const bananaY = parseInt(banana.style.top);
    const bananaRect = {
        left: bananaX, top: bananaY,
        right: bananaX + 25, bottom: bananaY + 35
    };
    
    if (this.rectsOverlap(playerRect, bananaRect)) {
        this.collectedBanana = true;
        this.showMessage('üçå Mysterious banana collected!');
        this.updateUI();
        this.saveGameState();
        banana.remove();
        // ADD THIS LINE TO REFRESH THE GORILLA:
        this.refreshGorilla();
    }
}

                

                // Check permanent money pickups
const permanentMoney = this.gameWorld.querySelectorAll('.money-pickup[data-type="permanentMoney"]');
permanentMoney.forEach(money => {
    const moneyX = parseInt(money.style.left);
    const moneyY = parseInt(money.style.top);
    const moneyRect = {
        left: moneyX, top: moneyY,
        right: moneyX + 22, bottom: moneyY + 22
    };
    
    if (this.rectsOverlap(playerRect, moneyRect)) {
        const value = parseInt(money.dataset.value);
        this.money += value;
        this.collectedMoney.push(money.dataset.id); // Track collection
        this.showMessage(`üí∞ +${value}¬• collected!`);
        this.updateUI();
        this.saveGameState(); // Autosave the collection
        money.remove();
    }
});



                

                const moneyDrops = this.gameWorld.querySelectorAll('.money-pickup[data-type="drop"]');
                moneyDrops.forEach(money => {
                    const moneyX = parseInt(money.style.left);
                    const moneyY = parseInt(money.style.top);
                    const moneyRect = {
                        left: moneyX, top: moneyY,
                        right: moneyX + 22, bottom: moneyY + 22
                    };
                    
                    if (this.rectsOverlap(playerRect, moneyRect)) {
                        this.money += 100;
                        this.showMessage('üí∞ +100¬• collected!');
                        this.updateUI();
                        this.saveGameState();
                        money.remove();
                    }
                });
                
                // Check destroyed pyramid
                const destroyedPyramid = this.gameWorld.querySelector('[data-type="destroyedPyramid"]');
                if (destroyedPyramid) {
                    const pyramidX = parseInt(destroyedPyramid.style.left);
                    const pyramidY = parseInt(destroyedPyramid.style.top);
                    const pyramidRect = {
                        left: pyramidX, top: pyramidY,
                        right: pyramidX + 60, bottom: pyramidY + 60
                    };
                    
                    if (this.rectsOverlap(playerRect, pyramidRect)) {
                        this.showMessage('üî∫ Pyramid Destroyed. Cannot Enter.');
                    }
                }

                // Check pink square hitbox (after gorilla encounter)
if (this.gorillaEncounterComplete && !this.pinkBossDefeated) {
    const pinkSquareX = 100; // x position of the pink square
    const pinkSquareY = 200; // y position of the pink square
    
    // Create expanded hitbox (5px around the 20x20 square)
    const pinkSquareRect = {
        left: pinkSquareX - 5,
        top: pinkSquareY - 5,
        right: pinkSquareX + 20 + 5,
        bottom: pinkSquareY + 20 + 5
    };
    
    if (this.rectsOverlap(playerRect, pinkSquareRect)) {
        // Transfer to cutscene
        this.transferToCutscene();
    }
}

                

// Check quicksand
const quicksands = this.gameWorld.querySelectorAll('[data-type="quicksand"]');
let inQuicksand = false;
let closestQuicksand = null;
let closestDistance = Infinity;

quicksands.forEach(quicksand => {
    const quicksandX = parseInt(quicksand.style.left);
    const quicksandY = parseInt(quicksand.style.top);
    const centerX = quicksandX + 30; // Center of 60px circle
    const centerY = quicksandY + 30;
    const distance = Math.sqrt(
        Math.pow(this.playerX + 12 - centerX, 2) + 
        Math.pow(this.playerY + 12 - centerY, 2)
    );
    
    if (distance <= 30) { // Within quicksand radius
        inQuicksand = true;
        if (distance < closestDistance) {
            closestDistance = distance;
            closestQuicksand = {x: centerX, y: centerY, distance: distance};
        }
    }
});

if (inQuicksand && closestQuicksand) {
    if (!this.sinkingInQuicksand) {
        this.sinkingInQuicksand = true;
        this.showMessage('‚ö†Ô∏è Quicksand! Swipe hard to escape!');
    }
    
    this.quicksandCenter = closestQuicksand;
    // Increase strength as you get closer to center
    this.quicksandStrength = Math.max(0.5, (30 - closestQuicksand.distance) / 30 * 2);
    
    // Death at very center (within 5px)
    if (closestQuicksand.distance <= 5) {
        this.showMessage('üíÄ Pulled into quicksand!');
        this.gameOver();
    }
} else {
    // Escaped quicksand
    if (this.sinkingInQuicksand) {
        this.sinkingInQuicksand = false;
        this.quicksandStrength = 0;
        this.quicksandCenter = null;
        this.showMessage('üèÉ Escaped the quicksand!');
    }
}



                
                // Check exit
                const exit = this.gameWorld.querySelector('.exit');
                if (exit) {
                    const exitX = parseInt(exit.style.left);
                    const exitY = parseInt(exit.style.top);
                    const exitRect = {
                        left: exitX, top: exitY,
                        right: exitX + 30, bottom: exitY + 30
                    };
                    
                    if (this.rectsOverlap(playerRect, exitRect)) {
                        if (this.hasKey) {
                            this.completeLevel();
                        } else {
                            this.showMessage('üîë You need a key to exit!');
                        }
                    }
                }
            }

            checkZoneEffects() {
    const playerCenterX = this.playerX + 12;
    const playerCenterY = this.playerY + 12;
    
    // Check lava zones FIRST - define onLava variable
    const lavaZones = this.gameWorld.querySelectorAll('[data-zone-type="lava"]');
    let onLava = false;
    
    for (let zone of lavaZones) {
        const zoneRect = {
            left: parseInt(zone.style.left),
            top: parseInt(zone.style.top),
            right: parseInt(zone.style.left) + parseInt(zone.style.width),
            bottom: parseInt(zone.style.top) + parseInt(zone.style.height)
        };
        
        if (playerCenterX >= zoneRect.left && playerCenterX <= zoneRect.right &&
            playerCenterY >= zoneRect.top && playerCenterY <= zoneRect.bottom) {
            onLava = true;
            break;
        }
    }
    
    // NOW use the onLava variable in the lava protection system
    if (onLava) {
        const now = Date.now();
        this.wasOnLava = true;
        
        if (this.hasLavaShoes) {
            // If just entered lava zone, start protection (but only if not already active)
            if (!this.lavaProtectionActive && this.lavaProtectionTime >= 5) {
                this.lavaProtectionActive = true;
                this.lavaProtectionTime = 5; // 5 seconds of protection
                this.showMessage('ü•æ ‚è∞5 seconds of protection');
            }
            
            // Count down protection time
            if (this.lavaProtectionActive && now - this.lastLavaZoneTime > 1000) {
                this.lavaProtectionTime--;
                this.lastLavaZoneTime = now;
                
                if (this.lavaProtectionTime > 0) {
                    this.showMessage(`ü•æ Protection: ${this.lavaProtectionTime} seconds left`);
                } else {
                    // Protection expired
                    this.lavaProtectionActive = false;
                    this.showMessage('ü•æ Protection expired! Escape the lava!');
                }
            }
            
            // Take damage if protection expired
            if (!this.lavaProtectionActive) {
                if (now - this.lastLavaDamage > 1000) {
                    this.takeDamage(2); // 2 hearts damage
                    this.showMessage('üî• Burning hot!');
                    this.lastLavaDamage = now;
                }
            }
        } else {
            // No shoes - take damage
            if (now - this.lastLavaDamage > 1000) {
                this.takeDamage(2); // 2 hearts damage
                this.showMessage('üî• Burning hot! You need special shoes!');
                this.lastLavaDamage = now;
            }
        }
    } else {
        // Not on lava - reset protection for next time (ONLY HERE)
        if (this.hasLavaShoes && this.lavaProtectionTime !== 5) {
            this.lavaProtectionActive = false;
            this.lavaProtectionTime = 5; // Reset to full protection
            if (this.wasOnLava) {  // Only show message if actually was on lava
                this.showMessage('ü•æ Left the lava! Power recharged for next time! ‚ò∫Ô∏è');
            }
        }
        this.wasOnLava = false; // Reset the flag
    }

    // Check if on desert zones
    const desertZones = this.gameWorld.querySelectorAll('[data-zone-type="desert"]');
    let onDesert = false;

    for (let zone of desertZones) {
        const zoneRect = {
            left: parseInt(zone.style.left),
            top: parseInt(zone.style.top),
            right: parseInt(zone.style.left) + parseInt(zone.style.width),
            bottom: parseInt(zone.style.top) + parseInt(zone.style.height)
        };
        
        if (playerCenterX >= zoneRect.left && playerCenterX <= zoneRect.right &&
            playerCenterY >= zoneRect.top && playerCenterY <= zoneRect.bottom) {
            onDesert = true;
            break;
        }
    }

    this.isOnDesert = onDesert;



                // Check if on water zones - change player to boat
const waterZones = this.gameWorld.querySelectorAll('[data-zone-type="water"]');
let onWater = false;

for (let zone of waterZones) {
    const zoneRect = {
        left: parseInt(zone.style.left),
        top: parseInt(zone.style.top),
        right: parseInt(zone.style.left) + parseInt(zone.style.width),
        bottom: parseInt(zone.style.top) + parseInt(zone.style.height)
    };
    
    if (playerCenterX >= zoneRect.left && playerCenterX <= zoneRect.right &&
        playerCenterY >= zoneRect.top && playerCenterY <= zoneRect.bottom) {
        onWater = true;
        break;
    }
}

// Switch player sprite based on water status
if (onWater && this.hasBoat && !this.boatIsBroken) {
    // On water with working boat - show boat emoji
    this.player.style.backgroundImage = '';
    this.player.textContent = '‚õµ';
    this.player.style.fontSize = '24px';
    this.player.style.display = 'flex';
    this.player.style.alignItems = 'center';
    this.player.style.justifyContent = 'center';
} else if (this.currentDirection) {
    // On land or no boat - show normal frog sprite
    this.player.style.backgroundImage = `url("https://raw.githubusercontent.com/TheDepression/Photos/main/${this.currentDirection}.PNG")`;
    this.player.textContent = '';
    this.player.style.fontSize = '';
}



                

    // Check if on forest zones
    const forestZones = this.gameWorld.querySelectorAll('[data-zone-type="forest"]');
    let onForest = false;

    for (let zone of forestZones) {
        const zoneRect = {
            left: parseInt(zone.style.left),
            top: parseInt(zone.style.top),
            right: parseInt(zone.style.left) + parseInt(zone.style.width),
            bottom: parseInt(zone.style.top) + parseInt(zone.style.height)
        };
        
        if (playerCenterX >= zoneRect.left && playerCenterX <= zoneRect.right &&
            playerCenterY >= zoneRect.top && playerCenterY <= zoneRect.bottom) {
            onForest = true;
            break;
        }
    }

    // Handle forest entry/exit
    if (onForest && !this.isInForest) {
        this.enterForest();
    } else if (!onForest && this.isInForest) {
        this.exitForest();
    }
}

            rectsOverlap(rect1, rect2) {
                return rect1.left < rect2.right &&
                       rect1.right > rect2.left &&
                       rect1.top < rect2.bottom &&
                       rect1.bottom > rect2.top;
            }
            
            takeDamage(damage = 1) { // Add parameter with default of 1
    if (this.isInvulnerable) return;
    
    this.hearts -= damage; // Use the damage parameter
    this.showMessage(damage > 1 ? 'üíîüíî Major damage!' : 'üíî Ouch!');
    this.updateUI();
    
    this.isInvulnerable = true;
    this.player.classList.add('invulnerable');
    
    setTimeout(() => {
        this.isInvulnerable = false;
        this.player.classList.remove('invulnerable');
    }, 1000);
    
    if (this.hearts <= 0) {
        this.gameOver();
    }
}
            
            showMessage(text) {
    const message = document.getElementById('message');
    message.textContent = text;
    message.style.display = 'block';
    this.currentMessageType = 'regular';
    
    clearTimeout(this.messageTimeout);
    this.messageTimeout = setTimeout(() => {
        if (this.currentMessageType === 'regular') { // Only clear if still a regular message
            message.style.display = 'none';
            this.currentMessageType = null;
        }
    }, 2000);
}

            showNPCMessage(text) {
    const message = document.getElementById('message');
    message.textContent = text;
    message.style.display = 'block';
    this.currentMessageType = 'npc';
    clearTimeout(this.messageTimeout); // Clear any existing timeout
    // No timeout - message stays until player moves away
}

checkBoatRepairTransaction(npc) {
    if (!this.boatIsBroken) {
        // Boat is already repaired
        this.showNPCMessage("üë©‚Äç‚öïÔ∏è Your boat looks fine to me! Safe travels!");
        return;
    }
    
    if (this.money >= 700) {
        // Player has enough money - show transaction option
        const now = Date.now();
        const interactionKey = 'boatRepair_1400_1330';
        
        // Prevent spam clicking (once per 3 seconds)
        if (this.lastInteractionTime[interactionKey] && 
            now - this.lastInteractionTime[interactionKey] < 3000) {
            return;
        }
        
        // Check if player just arrived (allow immediate first interaction)
        if (!this.lastInteractionTime[interactionKey]) {
            this.showNPCMessage("üë©‚Äç‚öïÔ∏è Your boat is broken? I can repair it for 700¬•. Stay here to confirm!");
            this.lastInteractionTime[interactionKey] = now - 2500; // Allow next interaction in 0.5s
            return;
        }
        
        // Second interaction - perform the transaction
        this.money -= 700;
        this.boatIsBroken = false;
        this.showNPCMessage("üë©‚Äç‚öïÔ∏è ‚õµ Boat repaired! You can now cross water safely!");
        this.updateUI();
        this.saveGameState();
        this.lastInteractionTime[interactionKey] = now;
        
        // Update the NPC's message permanently
        npc.dataset.message = "üë©‚Äç‚öïÔ∏è Your boat is working perfectly! Take care on the water!";
        
    } else {
        // Not enough money
        const needed = 700 - this.money;
        this.showNPCMessage(`üë©‚Äç‚öïÔ∏è Boat repair costs 700¬•. You need ${needed}¬• more!`);
    }
}

clearNPCMessage() {
    const message = document.getElementById('message');
    if (message.style.display === 'block' && this.currentMessageType === 'npc') {
        message.style.display = 'none';
        this.currentMessageType = null;
    }
}


            startGorillaDialog() {
    if (this.gorillaDialogStep > 0) return; // Prevent multiple triggers
    
    this.gorillaDialogStep = 1;
    this.gameStarted = false; // Pause game
    this.showGorillaDialog();
}

showGorillaDialog() {
    // Create dialog overlay
    const dialogOverlay = document.createElement('div');
    dialogOverlay.id = 'gorillaDialog';
    dialogOverlay.style.position = 'fixed';
    dialogOverlay.style.top = '0';
    dialogOverlay.style.left = '0';
    dialogOverlay.style.width = '100%';
    dialogOverlay.style.height = '100%';
    dialogOverlay.style.background = 'rgba(0,0,0,0.8)';
    dialogOverlay.style.display = 'flex';
    dialogOverlay.style.justifyContent = 'center';
    dialogOverlay.style.alignItems = 'center';
    dialogOverlay.style.zIndex = '400';
    
    const dialogBox = document.createElement('div');
    dialogBox.style.background = 'rgba(0,0,0,0.9)';
    dialogBox.style.color = 'white';
    dialogBox.style.padding = '20px';
    dialogBox.style.borderRadius = '10px';
    dialogBox.style.textAlign = 'center';
    dialogBox.style.maxWidth = '300px';
    dialogBox.style.border = '2px solid #555';
    
    // Add image
    const img = document.createElement('img');
    img.style.width = '80px';
    img.style.height = '80px';
    img.style.marginBottom = '15px';
    img.style.borderRadius = '8px';
    
    // Add text
    const text = document.createElement('p');
    text.style.margin = '10px 0';
    text.style.fontSize = '14px';
    
    // Add button
    const button = document.createElement('button');
    button.style.background = '#4CAF50';
    button.style.color = 'white';
    button.style.border = 'none';
    button.style.padding = '10px 20px';
    button.style.borderRadius = '5px';
    button.style.cursor = 'pointer';
    button.style.fontSize = '14px';
    
    // Set content based on step
    if (this.gorillaDialogStep === 1) {
        img.src = 'https://raw.githubusercontent.com/TheDepression/Photos/main/happygorilla.png';
        text.textContent = "ü¶ç Thanks! You're kind. I can trust you. Please listen to my story..";
        button.textContent = 'Next';
        button.onclick = () => {
            this.gorillaDialogStep = 2;
            dialogOverlay.remove();
            this.showGorillaDialog();
        };
    } else if (this.gorillaDialogStep === 2) {
        img.src = 'https://raw.githubusercontent.com/TheDepression/Photos/main/gfcat-min.png';
        text.textContent = "ü¶ç My girlfriend was locked in a cage by the bully on a pink square island in the water. I can't swim but you have a boat. Please get her!";
        button.textContent = 'Next';
        button.onclick = () => {
            this.gorillaDialogStep = 3;
            dialogOverlay.remove();
            this.showGorillaDialog();
        };
    } else if (this.gorillaDialogStep === 3) {
        img.src = 'https://raw.githubusercontent.com/TheDepression/Photos/main/orangehealth-min.png';
        text.textContent = "ü¶ç Take this power orange! It'll increase your gun power to 100 instead of 50. It will help you to rescue my beautiful girlfriend!";
        button.textContent = 'Accept Power';
        button.onclick = () => {
            this.completeGorillaEncounter();
            dialogOverlay.remove();
        };
    }
    
    dialogBox.appendChild(img);
    dialogBox.appendChild(text);
    dialogBox.appendChild(button);
    dialogOverlay.appendChild(dialogBox);
    document.body.appendChild(dialogOverlay);
}

completeGorillaEncounter() {
    // Remove banana from inventory and UI
    this.collectedBanana = false;
    
    // Give orange power upgrade
    this.hasOrangePower = true;
    this.attackDamage = 100;
    
    // Mark encounter as complete
    this.gorillaEncounterComplete = true;
    
    // Restart game and save
    this.gameStarted = true;
    this.updateUI();
    this.saveGameState();
    
    // Recreate the level to spawn friendly gorilla
    this.initLevel();
    
    this.showMessage('üçä Power Orange consumed! Gun damage increased to 100! üî´‚ö°');
}


            startGorillaFinalDialog() {
    if (this.gorillaFinalDialogComplete) return; // Prevent multiple triggers
    
    this.gameStarted = false; // Pause game
    this.showGorillaFinalDialog();
}

showGorillaFinalDialog() {
    const dialogOverlay = document.createElement('div');
    dialogOverlay.id = 'gorillaFinalDialog';
    dialogOverlay.style.position = 'fixed';
    dialogOverlay.style.top = '0';
    dialogOverlay.style.left = '0';
    dialogOverlay.style.width = '100%';
    dialogOverlay.style.height = '100%';
    dialogOverlay.style.background = 'rgba(0,0,0,0.8)';
    dialogOverlay.style.display = 'flex';
    dialogOverlay.style.justifyContent = 'center';
    dialogOverlay.style.alignItems = 'center';
    dialogOverlay.style.zIndex = '400';
    
    const dialogBox = document.createElement('div');
    dialogBox.style.background = 'rgba(0,0,0,0.9)';
    dialogBox.style.color = 'white';
    dialogBox.style.padding = '20px';
    dialogBox.style.borderRadius = '10px';
    dialogBox.style.textAlign = 'center';
    dialogBox.style.maxWidth = '300px';
    dialogBox.style.border = '2px solid #555';
    
    const img = document.createElement('img');
    img.src = 'https://raw.githubusercontent.com/TheDepression/Photos/main/happygorilla2.png';
    img.style.width = '80px';
    img.style.height = '80px';
    img.style.marginBottom = '15px';
    img.style.borderRadius = '8px';
    
    const text = document.createElement('p');
    text.style.margin = '10px 0';
    text.style.fontSize = '14px';
    text.textContent = "ü¶ç Thank you for rescuing my girlfriend! Here is your new power... hammer power on your gun! With this hammer power, your gun can now break through grey walls, and any cracked surfaces or walls you find... enjoy!";
    
    const button = document.createElement('button');
    button.style.background = '#4CAF50';
    button.style.color = 'white';
    button.style.border = 'none';
    button.style.padding = '10px 20px';
    button.style.borderRadius = '5px';
    button.style.cursor = 'pointer';
    button.style.fontSize = '14px';
    button.textContent = 'Accept Hammer Power';
    button.onclick = () => {
        this.completeGorillaFinalDialog();
        dialogOverlay.remove();
    };
    
    dialogBox.appendChild(img);
    dialogBox.appendChild(text);
    dialogBox.appendChild(button);
    dialogOverlay.appendChild(dialogBox);
    document.body.appendChild(dialogOverlay);
}

completeGorillaFinalDialog() {
    // Give hammer power upgrade
    this.hasHammerPower = true;
    
    // Mark final dialog as complete
    this.gorillaHammerDialogComplete = true;
    
    // Restart game and save
    this.gameStarted = true;
    this.updateUI();
    this.saveGameState();
    
    // Recreate the level to update gorilla message
    this.initLevel();
    
    this.showMessage('üî´üî® Hammer Power acquired! Gun can now break walls and weak points!');
}

startCatFirstDialog() {
    if (this.catFirstDialogComplete) return; // Prevent multiple triggers if already completed
    
    this.gameStarted = false; // Pause game
    this.showCatFirstDialog();
}

showCatFirstDialog() {
    const dialogOverlay = document.createElement('div');
    dialogOverlay.id = 'catFirstDialog';
    dialogOverlay.style.position = 'fixed';
    dialogOverlay.style.top = '0';
    dialogOverlay.style.left = '0';
    dialogOverlay.style.width = '100%';
    dialogOverlay.style.height = '100%';
    dialogOverlay.style.background = 'rgba(0,0,0,0.8)';
    dialogOverlay.style.display = 'flex';
    dialogOverlay.style.justifyContent = 'center';
    dialogOverlay.style.alignItems = 'center';
    dialogOverlay.style.zIndex = '400';
    
    const dialogBox = document.createElement('div');
    dialogBox.style.background = 'rgba(0,0,0,0.9)';
    dialogBox.style.color = 'white';
    dialogBox.style.padding = '20px';
    dialogBox.style.borderRadius = '10px';
    dialogBox.style.textAlign = 'center';
    dialogBox.style.maxWidth = '300px';
    dialogBox.style.border = '2px solid #555';
    
    const img = document.createElement('img');
    img.src = 'https://raw.githubusercontent.com/TheDepression/Photos/main/gfcat-min.png';
    img.style.width = '80px';
    img.style.height = '80px';
    img.style.marginBottom = '15px';
    img.style.borderRadius = '8px';
    
    const text = document.createElement('p');
    text.style.margin = '10px 0';
    text.style.fontSize = '14px';
    text.textContent = "The Brown monster is gone! It is a bit safer out here now. But the Bully kidnapped me because of my power to heal. He took my DNA. That's why he never stays down for long. Come here anytime to fill your health. Meow.";
    
    const button = document.createElement('button');
    button.style.background = '#4CAF50';
    button.style.color = 'white';
    button.style.border = 'none';
    button.style.padding = '10px 20px';
    button.style.borderRadius = '5px';
    button.style.cursor = 'pointer';
    button.style.fontSize = '14px';
    button.textContent = 'OK';
    button.onclick = () => {
        this.completeCatFirstDialog();
        dialogOverlay.remove();
    };
    
    dialogBox.appendChild(img);
    dialogBox.appendChild(text);
    dialogBox.appendChild(button);
    dialogOverlay.appendChild(dialogBox);
    document.body.appendChild(dialogOverlay);
}

completeCatFirstDialog() {
    // Mark cat dialog as seen and heal player
    this.catFirstDialogComplete = true;
    this.hearts = this.maxHearts;
    
    // Restart game and save
    this.gameStarted = true;
    this.updateUI();
    this.saveGameState();
    
    // Recreate the level to update cat message
    this.initLevel();
    
    this.showMessage('üíñ Health fully restored!');
}

handleCatHealing() {
    if (this.hearts < this.maxHearts) {
        this.hearts = this.maxHearts;
        this.showNPCMessage("Cat POWER!! -- You have full health.");
        this.updateUI();
        this.saveGameState();
    } else {
        this.showNPCMessage("Cat POWER!! -- You have full health.");
    }
}

transferToWeakPoint(url) {

    this.gameStarted = false; // ADD THIS LINE FIRST
    this.playerVelocityX = 0;
    this.playerVelocityY = 0;
    this.isDragging = false;
    // Save everything in one operation like the working transfers
    this.saveGameState();
    
    // Then just update the URL (but verify timeElapsed is preserved)
    const gameState = JSON.parse(localStorage.getItem('mfGameState'));
    gameState.currentUrl = url;
    gameState.timeElapsed = this.timeElapsed; // Ensure time is preserved
    gameState.lastSaveTime = Date.now();
    localStorage.setItem('mfGameState', JSON.stringify(gameState));
    
    this.showMessage('üï≥Ô∏è Entering the secret passage...');
    setTimeout(() => {
        window.location.href = `https://thedepression.github.io/games/minimaze/${url}`;
    }, 500);
}



            transferToCutscene() {
                this.gameStarted = false; // ADD THIS LINE FIRST
    this.playerVelocityX = 0;
    this.playerVelocityY = 0;
    this.isDragging = false;
    // Save everything in one operation like the working transfers
    this.saveGameState();
    // Save current game state before transfer
    this.saveGameState();
    
    // Update the current URL in the save state to track progression
    const gameState = JSON.parse(localStorage.getItem('mfGameState'));
    gameState.currentUrl = 'cutscene2';
                gameState.timeElapsed = this.timeElapsed; // Ensure time is preserved
    gameState.lastSaveTime = Date.now();
    localStorage.setItem('mfGameState', JSON.stringify(gameState));
    
    // Show transition message
    this.showMessage('üå∏ Approaching the mysterious island...');
    
    // Transfer after brief delay
    setTimeout(() => {
        window.location.href = 'https://thedepression.github.io/games/minimaze/cutscene2';
    }, 500);
}
        
            
            updateUI() {
    document.getElementById('hearts').textContent = this.hearts;
    document.getElementById('money').textContent = this.money;
                this.updateDeathCounter(); // ADD THIS LINE
    
    const ui = document.getElementById('ui');
    let itemsHTML = ''; // Change from itemsText to itemsHTML
    if (this.hasKey) itemsHTML += ' üîë';
    if (this.hasBoat && !this.boatIsBroken) itemsHTML += ' ‚õµ';
    if (this.hasBoat && this.boatIsBroken) itemsHTML += ' <span style="opacity: 0.3; filter: grayscale(100%);">‚õµ</span>';
    if (this.hasFlashlight) itemsHTML += ' üî¶';
    // Replace the gun section in updateUI() with this:
if (this.hasWeapon) {
    let gunStyle = '';
    
    // Determine base gun color/style
    if (this.hasSuperGun) {
        gunStyle = 'filter: brightness(0.3);'; // Deep black for super gun
    } else if (this.hasHammerPower) {
        gunStyle = 'filter: grayscale(0.9) brightness(0.8);'; // Grey for hammer
    } else if (this.hasOrangePower) {
        gunStyle = 'filter: hue-rotate(120deg) saturate(2) brightness(1.2);'; // Blue for orange
    } else {
        gunStyle = ''; // Default green
    }
    
    // Add pulse animation if enhanced range (preserving base color)
    if (this.hasEnhancedRange) {
        gunStyle += ' animation: gunPulsate 2s infinite; filter: ' + gunStyle.replace('filter: ', '') + ' drop-shadow(0 0 8px gold);';
    }
    
    itemsHTML += ` <span style="${gunStyle}">üî´</span>`;
}
    if (this.hasLavaShoes) itemsHTML += ' ü•æ';
                if (this.hasTrophy) itemsHTML += ' üèÜ';
               if (this.collectedBanana && !this.gorillaEncounterComplete) itemsHTML += ' üçå';
    
    if (!document.getElementById('items')) {
        const itemsDiv = document.createElement('div');
        itemsDiv.id = 'items';
        itemsDiv.innerHTML = '+' + itemsHTML; // Change to innerHTML
        ui.appendChild(itemsDiv);
    } else {
        document.getElementById('items').innerHTML = '+' + itemsHTML; // Change to innerHTML
    }
}
            
            completeLevel() {
                clearInterval(this.timerInterval);
                this.gameStarted = false;
                this.bgMusic.pause();
                this.showLevelComplete('üéâ Escaped the Wasteland!', 'You survived the post-apocalyptic world!');
            }
            
            gameOver() {
                this.deathCount++;
    this.updateDeathCounter();
              
                // SAVE IMMEDIATELY after death count increment
    this.saveGameState();
                this.sinkingInQuicksand = false;
    this.quicksandStrength = 0;
    this.quicksandCenter = null;
                clearInterval(this.timerInterval);
                this.gameStarted = false;
                this.bgMusic.pause();
                
                // Set recently died flag to prevent respawn exploit
                this.recentlyDied = true;
                setTimeout(() => {
                    this.recentlyDied = false;
                }, 180000); // 3 minutes
                
                const timeAtDeath = this.timeElapsed;
                
                this.showMessage('üíÄ You died! Returning to spawn point...');
                setTimeout(() => {
                    this.playerX = 140;
                    this.playerY = 1580;
                    this.timeElapsed = timeAtDeath; // Keep time penalty
                    this.hearts = 3; // Reset hearts
                    
                    this.initLevel();
                    this.startGameTimer();
                    this.saveGameState();
                    
                    this.showMessage('üîÑ Respawned - time penalty applied!');
                }, 3000);
            }
            
            showLevelComplete(title, text) {
                document.getElementById('levelCompleteTitle').textContent = title;
                document.getElementById('levelCompleteText').textContent = text;
                document.getElementById('levelComplete').style.display = 'flex';
            }


            transferToShop() {
    this.gameStarted = false;
    this.playerVelocityX = 0;
    this.playerVelocityY = 0;
    this.isDragging = false;
    
    this.saveGameState();
    
    const gameState = JSON.parse(localStorage.getItem('mfGameState'));
    gameState.currentUrl = 'shop';
    gameState.timeElapsed = this.timeElapsed;
    gameState.lastSaveTime = Date.now();
    localStorage.setItem('mfGameState', JSON.stringify(gameState));
    
    this.showMessage('üè™ Entering the shop...');
    setTimeout(() => {
        window.location.href = 'https://thedepression.github.io/games/minimaze/shop';
    }, 500);
}

handleBattleNPC() {
    const now = Date.now();
    const npcKey = 'battleNPC_1940_2020';
    
    // Prevent spam (5 second cooldown)
    if (this.lastInteractionTime[npcKey] && 
        now - this.lastInteractionTime[npcKey] < 5000) {
        return;
    }
    
    this.lastInteractionTime[npcKey] = now;
    
    if (this.hasTrophy) {
        this.showBattleDialogWithTrophy();
    } else {
        this.showBattleDialogNoTrophy();
    }
}

showBattleDialogNoTrophy() {
    this.gameStarted = false;
    
    const dialogOverlay = document.createElement('div');
    dialogOverlay.id = 'battleDialog';
    dialogOverlay.style.position = 'fixed';
    dialogOverlay.style.top = '0';
    dialogOverlay.style.left = '0';
    dialogOverlay.style.width = '100%';
    dialogOverlay.style.height = '100%';
    dialogOverlay.style.background = 'rgba(0,0,0,0.8)';
    dialogOverlay.style.display = 'flex';
    dialogOverlay.style.justifyContent = 'center';
    dialogOverlay.style.alignItems = 'center';
    dialogOverlay.style.zIndex = '400';
    
    const dialogBox = document.createElement('div');
    dialogBox.style.background = 'rgba(0,0,0,0.9)';
    dialogBox.style.color = 'white';
    dialogBox.style.padding = '20px';
    dialogBox.style.borderRadius = '10px';
    dialogBox.style.textAlign = 'center';
    dialogBox.style.maxWidth = '300px';
    dialogBox.style.border = '2px solid #555';
    
    const text = document.createElement('p');
    text.style.margin = '10px 0';
    text.style.fontSize = '14px';
    text.textContent = "ü§µüèª‚Äç‚ôÇÔ∏è Fight and win 5 monster battles in a row and I will give you a trophy üèÜ... give it a try?";
    
    const yesButton = document.createElement('button');
    yesButton.style.background = '#4CAF50';
    yesButton.style.color = 'white';
    yesButton.style.border = 'none';
    yesButton.style.padding = '10px 15px';
    yesButton.style.borderRadius = '5px';
    yesButton.style.cursor = 'pointer';
    yesButton.style.fontSize = '14px';
    yesButton.style.margin = '5px';
    yesButton.textContent = 'Yes';
    yesButton.onclick = () => {
        dialogOverlay.remove();
        this.transferToBattlezone();
    };
    
    const noButton = document.createElement('button');
    noButton.style.background = '#f44336';
    noButton.style.color = 'white';
    noButton.style.border = 'none';
    noButton.style.padding = '10px 15px';
    noButton.style.borderRadius = '5px';
    noButton.style.cursor = 'pointer';
    noButton.style.fontSize = '14px';
    noButton.style.margin = '5px';
    noButton.textContent = 'No';
    noButton.onclick = () => {
        dialogOverlay.remove();
        this.gameStarted = true;
        this.showMessage('ü§µüèª‚Äç‚ôÇÔ∏è Come back when you have courage!');
    };
    
    dialogBox.appendChild(text);
    dialogBox.appendChild(yesButton);
    dialogBox.appendChild(noButton);
    dialogOverlay.appendChild(dialogBox);
    document.body.appendChild(dialogOverlay);
}

showBattleDialogWithTrophy() {
    this.gameStarted = false;
    
    const dialogOverlay = document.createElement('div');
    dialogOverlay.id = 'battleDialog';
    dialogOverlay.style.position = 'fixed';
    dialogOverlay.style.top = '0';
    dialogOverlay.style.left = '0';
    dialogOverlay.style.width = '100%';
    dialogOverlay.style.height = '100%';
    dialogOverlay.style.background = 'rgba(0,0,0,0.8)';
    dialogOverlay.style.display = 'flex';
    dialogOverlay.style.justifyContent = 'center';
    dialogOverlay.style.alignItems = 'center';
    dialogOverlay.style.zIndex = '400';
    
    const dialogBox = document.createElement('div');
    dialogBox.style.background = 'rgba(0,0,0,0.9)';
    dialogBox.style.color = 'white';
    dialogBox.style.padding = '20px';
    dialogBox.style.borderRadius = '10px';
    dialogBox.style.textAlign = 'center';
    dialogBox.style.maxWidth = '300px';
    dialogBox.style.border = '2px solid #555';
    
    const text = document.createElement('p');
    text.style.margin = '10px 0';
    text.style.fontSize = '14px';
    text.textContent = "ü§µüèª‚Äç‚ôÇÔ∏è You were fantastic! Would you like to try again, just for fun?";
    
    const yesButton = document.createElement('button');
    yesButton.style.background = '#4CAF50';
    yesButton.style.color = 'white';
    yesButton.style.border = 'none';
    yesButton.style.padding = '10px 15px';
    yesButton.style.borderRadius = '5px';
    yesButton.style.cursor = 'pointer';
    yesButton.style.fontSize = '14px';
    yesButton.style.margin = '5px';
    yesButton.textContent = 'Yes';
    yesButton.onclick = () => {
        dialogOverlay.remove();
        this.transferToBattlezone();
    };
    
    const noButton = document.createElement('button');
    noButton.style.background = '#f44336';
    noButton.style.color = 'white';
    noButton.style.border = 'none';
    yesButton.style.padding = '10px 15px';
    noButton.style.borderRadius = '5px';
    noButton.style.cursor = 'pointer';
    noButton.style.fontSize = '14px';
    noButton.style.margin = '5px';
    noButton.textContent = 'No';
    noButton.onclick = () => {
        dialogOverlay.remove();
        this.gameStarted = true;
        this.showMessage('ü§µüèª‚Äç‚ôÇÔ∏è Thanks for visiting the arena!');
    };
    
    dialogBox.appendChild(text);
    dialogBox.appendChild(yesButton);
    dialogBox.appendChild(noButton);
    dialogOverlay.appendChild(dialogBox);
    document.body.appendChild(dialogOverlay);
}

transferToBattlezone() {
    this.gameStarted = false;
    this.playerVelocityX = 0;
    this.playerVelocityY = 0;
    this.isDragging = false;
    
    this.saveGameState();
    
    const gameState = JSON.parse(localStorage.getItem('mfGameState'));
    gameState.currentUrl = 'battlezone';
    gameState.timeElapsed = this.timeElapsed;
    gameState.lastSaveTime = Date.now();
    localStorage.setItem('mfGameState', JSON.stringify(gameState));
    
    this.showMessage('‚öîÔ∏è Entering the battle arena...');
    setTimeout(() => {
        window.location.href = 'https://thedepression.github.io/games/minimaze/battlezone';
    }, 500);
}
        }

        let game;

        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            game = new MazeGame();
            game.initLevel();
            game.startGameTimer();
        }

        function restartGame() {
            window.location.reload();
        }

        function pauseGame() {
    if (game && game.gameStarted) {
        game.isPaused = true;
        game.bgMusic.pause();
        game.forestMusic.pause(); // Also pause forest music
        document.getElementById('pauseMenu').style.display = 'flex';
    }
}

        function resumeGame() {
    if (game) {
        game.isPaused = false;
        document.getElementById('pauseMenu').style.display = 'none';
        
        // Resume appropriate music based on location
        if (game.isInForest) {
            game.forestMusic.play().catch(e => console.log('Forest music resume failed:', e));
        } else {
            game.bgMusic.play().catch(e => console.log('Music resume failed:', e));
        }
    }
}

        function returnToTitle() {
            if (game) {
                window.location.reload();
            }
        }

        function resetAllProgress() {
    if (confirm('Are you sure? This will delete ALL progress and restart from the very beginning of Master Frog\'s Adventure.')) {
        // Clear all Master Frog related localStorage except name (keep the name)
        const playerName = localStorage.getItem('mfPlayerName');
        const keys = Object.keys(localStorage);
        keys.forEach(key => {
            if (key.startsWith('mf')) {
                localStorage.removeItem(key);
            }
        });
        
        // Restore the name if it existed
        if (playerName) {
            localStorage.setItem('mfPlayerName', playerName);
        }
        
        // Redirect to the very beginning
        window.location.href = 'https://thedepression.github.io/games/minimaze/maze1';
    }
}

        function confirmAction() {
    document.getElementById('confirmDialog').style.display = 'none';
    game.gameStarted = true;
    
    if (game.pendingAction === 'enterForest') {
        game.isInForest = true;
        game.bgMusic.pause();
        game.forestMusic.play().catch(e => console.log('Forest music play failed:', e));
        document.getElementById('forestOverlay').classList.add('active');
        document.getElementById('forestVisionMask').classList.add('active');
        game.showMessage('üå≤ Entering the forest...');
        game.updateForestVisibility();
    } else if (game.pendingAction === 'exitForest') {
        game.isInForest = false;
        game.forestMusic.pause();
        game.bgMusic.play().catch(e => console.log('Music play failed:', e));
        document.getElementById('forestOverlay').classList.remove('active');
        document.getElementById('forestVisionMask').classList.remove('active');
        game.showMessage('üåû Left the forest!');
        game.updateForestVisibility();
    }
    
    game.pendingAction = null;
}
    </script>
</body>
</html>
