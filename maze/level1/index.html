<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hospital Maze - Level 1</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            background: #e8f4f8;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 18px;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            display: grid;
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: repeat(3, 60px);
            gap: 5px;
        }
        
        .control-btn {
            background: rgba(255,255,255,0.8);
            border: 2px solid #333;
            border-radius: 10px;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
        }
        
        .control-btn:active {
            background: rgba(255,255,255,0.9);
            transform: scale(0.95);
        }
        
        #gameOverScreen, #levelCompleteScreen, #characterSelect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 200;
        }
        
        .menu-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 30px;
            margin: 10px;
            border-radius: 5px;
            font-size: 18px;
            cursor: pointer;
        }
        
        .menu-button:hover {
            background: #45a049;
        }
        
        .character-option {
            font-size: 48px;
            margin: 10px;
            cursor: pointer;
            padding: 10px;
            border: 3px solid transparent;
            border-radius: 10px;
        }
        
        .character-option:hover, .character-option.selected {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.2);
        }
        
        #foregroundEnemy {
            position: absolute;
            font-size: 72px;
            z-index: 50;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="ui">
            <div>‚ù§Ô∏è Hearts: <span id="hearts">3</span></div>
            <div>üí∞ Money: <span id="money">0</span>/500</div>
            <div>üóùÔ∏è Keys: <span id="keys">0</span></div>
        </div>
        
        <div id="controls">
            <div></div>
            <div class="control-btn" onclick="move('up')">‚¨ÜÔ∏è</div>
            <div></div>
            <div class="control-btn" onclick="move('left')">‚¨ÖÔ∏è</div>
            <div class="control-btn" onclick="move('down')">‚¨áÔ∏è</div>
            <div class="control-btn" onclick="move('right')">‚û°Ô∏è</div>
            <div></div>
            <div></div>
            <div class="control-btn" onclick="interact()">üí¨</div>
        </div>
        
        <div id="foregroundEnemy"></div>
        
        <div id="characterSelect">
            <h2>Select Your Character</h2>
            <div>
                <div class="character-option selected" onclick="selectCharacter('üòé')" data-char="üòé">üòé</div>
                <div class="character-option" onclick="selectCharacter('ü§¢')" data-char="ü§¢">ü§¢</div>
                <div class="character-option" onclick="selectCharacter('üò∫')" data-char="üò∫">üò∫</div>
                <div class="character-option" onclick="selectCharacter('üë©üèª')" data-char="üë©üèª">üë©üèª</div>
                <div class="character-option" onclick="selectCharacter('üë©üèΩ‚Äçü¶±')" data-char="üë©üèΩ‚Äçü¶±">üë©üèΩ‚Äçü¶±</div>
                <div class="character-option" onclick="selectCharacter('üôçüèª‚Äç‚ôÇÔ∏è')" data-char="üôçüèª‚Äç‚ôÇÔ∏è">üôçüèª‚Äç‚ôÇÔ∏è</div>
            </div>
            <button class="menu-button" onclick="startGame()">Start Game</button>
        </div>
        
        <div id="gameOverScreen">
            <h2>Game Over!</h2>
            <button class="menu-button" onclick="restartGame()">Retry</button>
            <button class="menu-button" onclick="showCharacterSelect()">Change Character</button>
        </div>
        
        <div id="levelCompleteScreen">
            <h2>Level Complete!</h2>
            <button class="menu-button" onclick="nextLevel()">Next Level</button>
            <button class="menu-button" onclick="showCharacterSelect()">Change Character</button>
        </div>
    </div>

    <script>
        // Game variables
        let canvas = document.getElementById('gameCanvas');
        let ctx = canvas.getContext('2d');
        let gameState = 'characterSelect';
        let selectedCharacter = 'üòé';
        
        // Resize canvas to fill screen
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Game state
        let player = {
            x: 50,
            y: 50,
            size: 32,
            char: selectedCharacter
        };
        
        let gameStats = {
            hearts: parseInt(localStorage.getItem('playerHearts')) || 3,
            money: 0,
            keys: 0,
            maxHearts: 3
        };
        
        // Camera
        let camera = {
            x: 0,
            y: 0
        };
        
        // Map dimensions
        const TILE_SIZE = 40;
        const MAP_WIDTH = 30;
        const MAP_HEIGHT = 25;
        
        // Generate maze with interior walls
        let maze = [];
        
        function generateMaze() {
            // Initialize with walls
            for (let y = 0; y < MAP_HEIGHT; y++) {
                maze[y] = [];
                for (let x = 0; x < MAP_WIDTH; x++) {
                    maze[y][x] = 'üß±';
                }
            }
            
            // Create paths
            function carvePath(x, y) {
                maze[y][x] = '‚¨ú';
                
                const directions = [[0, 2], [2, 0], [0, -2], [-2, 0]];
                directions.sort(() => Math.random() - 0.5);
                
                for (let [dx, dy] of directions) {
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    if (nx > 0 && nx < MAP_WIDTH - 1 && ny > 0 && ny < MAP_HEIGHT - 1 && maze[ny][nx] === 'üß±') {
                        maze[y + dy/2][x + dx/2] = '‚¨ú';
                        carvePath(nx, ny);
                    }
                }
            }
            
            carvePath(1, 1);
            
            // Add interior walls from edges
            for (let i = 0; i < 8; i++) {
                // Top wall extensions
                let x = Math.floor(Math.random() * (MAP_WIDTH - 4)) + 2;
                let length = Math.floor(Math.random() * 4) + 2;
                for (let j = 0; j < length && j + 1 < MAP_HEIGHT; j++) {
                    if (maze[j + 1][x] === '‚¨ú') maze[j + 1][x] = 'üß±';
                }
                
                // Bottom wall extensions
                x = Math.floor(Math.random() * (MAP_WIDTH - 4)) + 2;
                length = Math.floor(Math.random() * 4) + 2;
                for (let j = 0; j < length && MAP_HEIGHT - j - 2 > 0; j++) {
                    if (maze[MAP_HEIGHT - j - 2][x] === '‚¨ú') maze[MAP_HEIGHT - j - 2][x] = 'üß±';
                }
                
                // Left wall extensions
                let y = Math.floor(Math.random() * (MAP_HEIGHT - 4)) + 2;
                length = Math.floor(Math.random() * 4) + 2;
                for (let j = 0; j < length && j + 1 < MAP_WIDTH; j++) {
                    if (maze[y][j + 1] === '‚¨ú') maze[y][j + 1] = 'üß±';
                }
                
                // Right wall extensions
                y = Math.floor(Math.random() * (MAP_HEIGHT - 4)) + 2;
                length = Math.floor(Math.random() * 4) + 2;
                for (let j = 0; j < length && MAP_WIDTH - j - 2 > 0; j++) {
                    if (maze[y][MAP_WIDTH - j - 2] === '‚¨ú') maze[y][MAP_WIDTH - j - 2] = 'üß±';
                }
            }
        }
        
        // Game entities
        let money = [];
        let enemies = [];
        let npcs = [];
        let doors = [];
        
        function spawnEntities() {
            money = [];
            enemies = [];
            npcs = [];
            doors = [];
            
            // Spawn money (500 coins)
            for (let i = 0; i < 500; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * MAP_WIDTH);
                    y = Math.floor(Math.random() * MAP_HEIGHT);
                } while (maze[y][x] !== '‚¨ú' || (x < 3 && y < 3));
                
                money.push({
                    x: x * TILE_SIZE + TILE_SIZE/2,
                    y: y * TILE_SIZE + TILE_SIZE/2,
                    collected: false
                });
            }
            
            // Spawn key dealer NPC
            let dealerX, dealerY;
            do {
                dealerX = Math.floor(Math.random() * MAP_WIDTH);
                dealerY = Math.floor(Math.random() * MAP_HEIGHT);
            } while (maze[dealerY][dealerX] !== '‚¨ú' || (dealerX < 5 && dealerY < 5));
            
            npcs.push({
                x: dealerX * TILE_SIZE + TILE_SIZE/2,
                y: dealerY * TILE_SIZE + TILE_SIZE/2,
                char: 'üè•',
                type: 'keyDealer',
                message: 'I have a key for 500 yen! Collect all the money first.',
                soldKey: false
            });
            
            // Spawn door
            doors.push({
                x: (MAP_WIDTH - 2) * TILE_SIZE + TILE_SIZE/2,
                y: (MAP_HEIGHT - 2) * TILE_SIZE + TILE_SIZE/2,
                char: 'üö™',
                locked: true
            });
            
            // Spawn more enemies (viruses and needles)
            const enemyTypes = ['ü¶†', 'üíâ', 'ü©∏', '‚öóÔ∏è', 'üß™'];
            for (let i = 0; i < 25; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * MAP_WIDTH);
                    y = Math.floor(Math.random() * MAP_HEIGHT);
                } while (maze[y][x] !== '‚¨ú' || (x < 4 && y < 4));
                
                enemies.push({
                    x: x * TILE_SIZE + TILE_SIZE/2,
                    y: y * TILE_SIZE + TILE_SIZE/2,
                    char: enemyTypes[Math.floor(Math.random() * enemyTypes.length)],
                    dx: (Math.random() - 0.5) * 2,
                    dy: (Math.random() - 0.5) * 2,
                    speed: 0.5 + Math.random() * 0.5
                });
            }
        }
        
        // Foreground enemy
        let foregroundEnemy = {
            active: false,
            x: -100,
            y: 0,
            char: 'ü¶†',
            speed: 3,
            direction: 1,
            lastSpawn: 0
        };
        
        function spawnForegroundEnemy() {
            if (Date.now() - foregroundEnemy.lastSpawn < (20000 + Math.random() * 30000)) return;
            
            foregroundEnemy.active = true;
            foregroundEnemy.direction = Math.random() > 0.5 ? 1 : -1;
            foregroundEnemy.x = foregroundEnemy.direction === 1 ? -100 : canvas.width + 100;
            foregroundEnemy.y = canvas.height / 2 - 36;
            foregroundEnemy.lastSpawn = Date.now();
            
            document.getElementById('foregroundEnemy').style.display = 'block';
            document.getElementById('foregroundEnemy').innerHTML = foregroundEnemy.char;
        }
        
        function updateForegroundEnemy() {
            if (!foregroundEnemy.active) return;
            
            foregroundEnemy.x += foregroundEnemy.speed * foregroundEnemy.direction;
            
            document.getElementById('foregroundEnemy').style.left = foregroundEnemy.x + 'px';
            document.getElementById('foregroundEnemy').style.top = foregroundEnemy.y + 'px';
            
            // Check collision with player (screen center)
            const playerScreenX = canvas.width / 2;
            const playerScreenY = canvas.height / 2;
            
            if (Math.abs(foregroundEnemy.x - playerScreenX) < 50 && 
                Math.abs(foregroundEnemy.y - playerScreenY) < 50) {
                takeDamage();
            }
            
            // Remove when off screen
            if ((foregroundEnemy.direction === 1 && foregroundEnemy.x > canvas.width + 100) ||
                (foregroundEnemy.direction === -1 && foregroundEnemy.x < -100)) {
                foregroundEnemy.active = false;
                document.getElementById('foregroundEnemy').style.display = 'none';
            }
        }
        
        // Input handling
        let keys = {};
        
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        function move(direction) {
            if (gameState !== 'playing') return;
            
            let newX = player.x;
            let newY = player.y;
            const moveSpeed = TILE_SIZE;
            
            switch(direction) {
                case 'up': newY -= moveSpeed; break;
                case 'down': newY += moveSpeed; break;
                case 'left': newX -= moveSpeed; break;
                case 'right': newX += moveSpeed; break;
            }
            
            // Check collision with walls
            const gridX = Math.floor(newX / TILE_SIZE);
            const gridY = Math.floor(newY / TILE_SIZE);
            
            if (gridX >= 0 && gridX < MAP_WIDTH && 
                gridY >= 0 && gridY < MAP_HEIGHT && 
                maze[gridY][gridX] === '‚¨ú') {
                player.x = newX;
                player.y = newY;
                
                // Collect money
                money.forEach(coin => {
                    if (!coin.collected && 
                        Math.abs(player.x - coin.x) < TILE_SIZE/2 && 
                        Math.abs(player.y - coin.y) < TILE_SIZE/2) {
                        coin.collected = true;
                        gameStats.money++;
                        updateUI();
                    }
                });
                
                // Check door
                doors.forEach(door => {
                    if (Math.abs(player.x - door.x) < TILE_SIZE/2 && 
                        Math.abs(player.y - door.y) < TILE_SIZE/2) {
                        if (gameStats.keys > 0) {
                            completeLevel();
                        }
                    }
                });
            }
        }
        
        function interact() {
            npcs.forEach(npc => {
                if (Math.abs(player.x - npc.x) < TILE_SIZE && 
                    Math.abs(player.y - npc.y) < TILE_SIZE) {
                    if (npc.type === 'keyDealer') {
                        if (!npc.soldKey && gameStats.money >= 500) {
                            npc.soldKey = true;
                            npc.message = 'Arigato gozaimashita! üóùÔ∏è';
                            gameStats.keys++;
                            updateUI();
                            alert(npc.message);
                        } else if (!npc.soldKey) {
                            alert(npc.message);
                        } else {
                            alert(npc.message);
                        }
                    }
                }
            });
        }
        
        // Game mechanics
        function updateEnemies() {
            enemies.forEach(enemy => {
                enemy.x += enemy.dx * enemy.speed;
                enemy.y += enemy.dy * enemy.speed;
                
                // Bounce off walls
                const gridX = Math.floor(enemy.x / TILE_SIZE);
                const gridY = Math.floor(enemy.y / TILE_SIZE);
                
                if (gridX < 0 || gridX >= MAP_WIDTH || gridY < 0 || gridY >= MAP_HEIGHT || 
                    maze[gridY][gridX] === 'üß±') {
                    enemy.dx *= -1;
                    enemy.dy *= -1;
                    enemy.x += enemy.dx * enemy.speed * 2;
                    enemy.y += enemy.dy * enemy.speed * 2;
                }
                
                // Check collision with player
                if (Math.abs(player.x - enemy.x) < TILE_SIZE/2 && 
                    Math.abs(player.y - enemy.y) < TILE_SIZE/2) {
                    takeDamage();
                }
            });
        }
        
        function takeDamage() {
            gameStats.hearts--;
            updateUI();
            
            if (gameStats.hearts <= 0) {
                gameOver();
            }
        }
        
        function updateCamera() {
            camera.x = player.x - canvas.width / 2;
            camera.y = player.y - canvas.height / 2;
        }
        
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw maze
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    const screenX = x * TILE_SIZE - camera.x;
                    const screenY = y * TILE_SIZE - camera.y;
                    
                    if (screenX > -TILE_SIZE && screenX < canvas.width && 
                        screenY > -TILE_SIZE && screenY < canvas.height) {
                        ctx.font = `${TILE_SIZE}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.fillText(maze[y][x], screenX + TILE_SIZE/2, screenY + TILE_SIZE*0.8);
                    }
                }
            }
            
            // Draw money
            ctx.font = '20px Arial';
            money.forEach(coin => {
                if (!coin.collected) {
                    const screenX = coin.x - camera.x;
                    const screenY = coin.y - camera.y;
                    if (screenX > -50 && screenX < canvas.width + 50 && 
                        screenY > -50 && screenY < canvas.height + 50) {
                        ctx.fillText('üí∞', screenX, screenY);
                    }
                }
            });
            
            // Draw NPCs
            ctx.font = '32px Arial';
            npcs.forEach(npc => {
                const screenX = npc.x - camera.x;
                const screenY = npc.y - camera.y;
                ctx.fillText(npc.char, screenX, screenY);
            });
            
            // Draw doors
            doors.forEach(door => {
                const screenX = door.x - camera.x;
                const screenY = door.y - camera.y;
                ctx.fillText(door.char, screenX, screenY);
            });
            
            // Draw enemies
            enemies.forEach(enemy => {
                const screenX = enemy.x - camera.x;
                const screenY = enemy.y - camera.y;
                if (screenX > -50 && screenX < canvas.width + 50 && 
                    screenY > -50 && screenY < canvas.height + 50) {
                    ctx.fillText(enemy.char, screenX, screenY);
                }
            });
            
            // Draw player (always at center)
            ctx.font = '32px Arial';
            ctx.fillText(player.char, canvas.width / 2, canvas.height / 2);
        }
        
        // Game states
        function selectCharacter(char) {
            selectedCharacter = char;
            player.char = char;
            
            document.querySelectorAll('.character-option').forEach(opt => {
                opt.classList.remove('selected');
            });
            document.querySelector(`[data-char="${char}"]`).classList.add('selected');
        }
        
        function startGame() {
            gameState = 'playing';
            document.getElementById('characterSelect').style.display = 'none';
            
            // Reset game state
            gameStats.money = 0;
            gameStats.keys = 0;
            
            player.x = 50;
            player.y = 50;
            
            generateMaze();
            spawnEntities();
            updateUI();
            
            gameLoop();
        }
        
        function restartGame() {
            gameStats.hearts = gameStats.maxHearts;
            gameStats.money = 0;
            gameStats.keys = 0;
            localStorage.removeItem('playerHearts'); // Reset hearts on restart
            
            startGame();
            document.getElementById('gameOverScreen').style.display = 'none';
        }
        
        function gameOver() {
            gameState = 'gameOver';
            document.getElementById('gameOverScreen').style.display = 'flex';
        }
        
        function completeLevel() {
            gameState = 'levelComplete';
            localStorage.setItem('playerHearts', gameStats.hearts.toString());
            document.getElementById('levelCompleteScreen').style.display = 'flex';
        }
        
        function nextLevel() {
            // This would link to level 2
            alert('Level 2 coming soon!');
            showCharacterSelect();
        }
        
        function showCharacterSelect() {
            gameState = 'characterSelect';
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('levelCompleteScreen').style.display = 'none';
            document.getElementById('characterSelect').style.display = 'flex';
        }
        
        function updateUI() {
            document.getElementById('hearts').textContent = gameStats.hearts;
            document.getElementById('money').textContent = gameStats.money;
            document.getElementById('keys').textContent = gameStats.keys;
        }
        
        // Game loop
        function gameLoop() {
            if (gameState === 'playing') {
                // Handle keyboard input
                if (keys['ArrowUp'] || keys['w'] || keys['W']) move('up');
                if (keys['ArrowDown'] || keys['s'] || keys['S']) move('down');
                if (keys['ArrowLeft'] || keys['a'] || keys['A']) move('left');
                if (keys['ArrowRight'] || keys['d'] || keys['D']) move('right');
                if (keys[' '] || keys['Enter']) interact();
                
                updateEnemies();
                updateCamera();
                spawnForegroundEnemy();
                updateForegroundEnemy();
                render();
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // Initialize
        updateUI();
        document.getElementById('characterSelect').style.display = 'flex';
    </script>
</body>
</html>
